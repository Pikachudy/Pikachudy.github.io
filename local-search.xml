<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>文件管理-OS课程项目</title>
    <link href="/2022/06/16/%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86-OS%E8%AF%BE%E7%A8%8B%E9%A1%B9%E7%9B%AE/"/>
    <url>/2022/06/16/%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86-OS%E8%AF%BE%E7%A8%8B%E9%A1%B9%E7%9B%AE/</url>
    
    <content type="html"><![CDATA[<h1 id="文件管理——文件系统管理"><a href="#文件管理——文件系统管理" class="headerlink" title="文件管理——文件系统管理"></a>文件管理——文件系统管理</h1><p>[TOC]</p><h3 id="开发环境"><a href="#开发环境" class="headerlink" title="开发环境"></a>开发环境</h3><p>开发语言：Javascript+html+css</p><p>开发框架：Vue.js 3.0+Element-plus</p><p>开发工具：Vue-cli、Vue-devtools、VScode、Edge</p><h3 id="实现方法"><a href="#实现方法" class="headerlink" title="实现方法"></a>实现方法</h3><p>引入Element-plus组件作为UI，采用Vue3框架进行组件化开发</p><p>采用 JS 在内存中开辟的空间作为文件资源管理器所需的内存部分，使用浏览器缓存（localStorage）作为外部磁盘，将文件写入的数据存至其中。</p><p>在退出资源管理器时（即关闭浏览器页面）将必要的目录文件结构（如位图、文件目录等）也一并存入浏览器缓存中，模拟关闭系统时文件存入磁盘。在下次访问时从浏览器缓存中读取目录文件结构数据，模拟进入系统后从磁盘中取出文件目录等操作。</p><h3 id="项目浏览"><a href="#项目浏览" class="headerlink" title="项目浏览"></a>项目浏览</h3><ul><li>联网进入[<a href="https://pikachudy.github.io/Documents_System/">Documents_System (pikachudy.github.io)</a>]在线浏览</li></ul><p><strong>请注意：</strong></p><ul><li>由于使用了浏览器缓存来存放数据，不同浏览器之间、同一浏览器不同域名下缓存不能共享，因此 <strong>请使用同一浏览器打开项目</strong>，以顺利读取上一次退出时保存的内容</li><li>请确保浏览器<strong>不处于无痕模式&#x2F;安全模式</strong>，以确保浏览器允许缓存写入</li><li>本项目在Edge、FireFox、Chrom、Mac端Safari均进行过测试，可正常读写缓存</li></ul><h3 id="主要变量及数据结构介绍"><a href="#主要变量及数据结构介绍" class="headerlink" title="主要变量及数据结构介绍"></a>主要变量及数据结构介绍</h3><p>实现功能的主要文件为<strong>DocumentPage.vue</strong></p><h4 id="文件预览"><a href="#文件预览" class="headerlink" title="文件预览"></a>文件预览</h4><table><thead><tr><th>文件名称</th><th align="center">负责内容</th><th>子组件</th></tr></thead><tbody><tr><td>App.vue</td><td align="center">页面根组件</td><td>DocumentPage.vue</td></tr><tr><td>DocumentPage.vue</td><td align="center">实现页面UI展示、整体逻辑</td><td>null</td></tr></tbody></table><h4 id="源码变量介绍"><a href="#源码变量介绍" class="headerlink" title="源码变量介绍"></a>源码变量介绍</h4><h5 id="DocumentPage-vue"><a href="#DocumentPage-vue" class="headerlink" title="DocumentPage.vue"></a>DocumentPage.vue</h5><h6 id="维护变量"><a href="#维护变量" class="headerlink" title="维护变量"></a>维护变量</h6><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> &#123;<br>      <span class="hljs-comment">/*主要配置*/</span><br>      <span class="hljs-comment">//当前所在路径</span><br>      <span class="hljs-attr">cur_path</span>: [],<br>      <span class="hljs-comment">//当前所在目录</span><br>      <span class="hljs-attr">cur_dir</span>: [],<br>      <span class="hljs-comment">//文件目录——采用树的数据结构</span><br>      <span class="hljs-attr">totol_dir</span>: [<br>        &#123;<br>          <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Data(D:)&quot;</span>,<br>          <span class="hljs-attr">last_edit_timestr</span>: <span class="hljs-string">&quot;2001/10/23&quot;</span>,<br>          <span class="hljs-attr">last_edit_time</span>: -<span class="hljs-number">1</span>,<br>          <span class="hljs-attr">type</span>: <span class="hljs-number">2</span>,<br>          <span class="hljs-attr">size</span>: <span class="hljs-string">&quot;64&quot;</span>,<br>          <span class="hljs-attr">used_space</span>: <span class="hljs-string">&quot;&quot;</span>,<br>          <span class="hljs-attr">path</span>: <span class="hljs-string">&quot;&quot;</span>,<br>          <span class="hljs-attr">children</span>: [],<br>          <span class="hljs-attr">p_begin</span>: -<span class="hljs-number">1</span>, <span class="hljs-comment">//非文件类型不需要设置此项</span><br>          <span class="hljs-attr">p_end</span>: -<span class="hljs-number">1</span>, <span class="hljs-comment">//非文件类型不需要设置此项</span><br>        &#125;,<br>      ],<br>      <span class="hljs-comment">//一个磁盘64 KB，分为128块，每块大小为 512 B</span><br>      <span class="hljs-attr">disk_bitmap</span>: [<br>        &#123;<br>          <span class="hljs-attr">disk</span>: <span class="hljs-string">&quot;D&quot;</span>,<br>          <span class="hljs-attr">bolck_size</span>: <span class="hljs-number">512</span>,<br>          <span class="hljs-attr">block_free_num</span>: <span class="hljs-number">512</span>,<br>          <span class="hljs-attr">bitmap</span>:   <span class="hljs-string">&quot;00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000&quot;</span>,<br>        &#125;,<br>      ],<br>      <span class="hljs-comment">//在此模拟外部的硬盘，在created钩子中初始化</span><br>      <span class="hljs-attr">physical_disk</span>: [],<br>    ...<br>    &#125;;<br>  &#125;,<br></code></pre></td></tr></table></figure><h6 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h6><p>组件内部维护了文件资源管理器所需的状态变量及必要数据结构，除了基本的状态参数外，使用了对象数组 <strong>total_dir</strong> 作为文件目录表，其中每个对象相当于一个 FCB ,  <strong>disk_bitmp</strong> 模拟使用位图来管理空闲块信息；<strong>physical_disk</strong> 模拟外部磁盘空间，存放文件内容</p><p>在退出系统前会将以上信息转换为 JSON 格式，存放入浏览器本地缓存中（使用 windows.localStorage 对象），在每次进入系统时将会读取缓存，恢复上次离开时的状态。</p><h6 id="主要对象属性介绍"><a href="#主要对象属性介绍" class="headerlink" title="主要对象属性介绍"></a>主要对象属性介绍</h6><ol><li><p><strong>totol_dir</strong> 使用<strong>树的数据结构</strong>组织 FCB 项，采用<strong>链接结构管理文件存储空间</strong>，其中每一项 FCB 主要包含以下属性：</p><ul><li><p>name：文件名</p></li><li><p>last_edit_time:  最后修改时间的时间戳</p></li><li><p>type：文件类型——磁盘&#x2F;文件夹&#x2F;可读写文件</p></li><li><p>size：文件大小（以 KB 为单位）</p></li><li><p>path：文件路径</p></li><li><p>children：包含的子文件（夹）</p></li><li><p>p_begin：块指针，指向起始位置</p></li><li><p>p_end：块指针，指向终止位置</p></li></ul></li><li><p><strong>disk_bitmp</strong> 是一个数组，原本考虑到了多个磁盘（C、D、E、F），每个磁盘均有一个位图管理空闲空间，但时间原因最终只写了一个磁盘：</p><ul><li><p>disk：磁盘号</p></li><li><p>block_size: 一个块的大小（单位为 B）</p></li><li><p>bitmap：由于 JS 无法直接操作比特位，因此使用字符串数组来模拟</p></li></ul></li><li><p><strong>physical_disk</strong> 是一个数组，模拟外部磁盘，其中的每一个对象元素为一个磁盘块，每个元素的属性为：</p><ul><li>block_num：块号</li><li>content：存放内容</li><li>disk_next：采用链接结构管理文件存储空间，此处指向下一块块号</li></ul><p>由于块数比较多，不便于以字面量形式初始化，因此在 created 钩子中调用相应函数进行初始化，初始化代码如下：</p></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title function_">physicalDiskInit</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">64</span>; ++i) &#123;<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">physical_disk</span>.<span class="hljs-title function_">push</span>(&#123;<br>        <span class="hljs-attr">block_num</span>: i,<br>        <span class="hljs-attr">content</span>: <span class="hljs-string">&quot;&quot;</span>,<br>        <span class="hljs-attr">des_content</span>: <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-comment">//便于在侧栏展示内容，只展示前10个字符</span><br>        <span class="hljs-attr">disk_next</span>: -<span class="hljs-number">1</span>,<br>      &#125;);<br>    &#125;<br>  &#125;,<br></code></pre></td></tr></table></figure><h3 id="主要功能设计及实现"><a href="#主要功能设计及实现" class="headerlink" title="主要功能设计及实现"></a>主要功能设计及实现</h3><h4 id="管理方式"><a href="#管理方式" class="headerlink" title="管理方式"></a>管理方式</h4><ol><li>文件目录——多级目录</li><li>文件存储空间管理——链接结构</li><li>空闲空间管理——位图</li></ol><h4 id="新建文件"><a href="#新建文件" class="headerlink" title="新建文件"></a>新建文件</h4><ol><li>由于文件目录以多级目录方式组织，因此直接遍历树找到当前目录下新建的文件所属的直接父文件夹（父结点）</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> dir = <span class="hljs-variable language_">this</span>.<span class="hljs-property">totol_dir</span>; <span class="hljs-comment">//保存当前层的情况</span><br>    <span class="hljs-comment">//这里的i相当于深度</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-variable language_">this</span>.<span class="hljs-property">cur_path</span>.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>; ++i) &#123;<br>      <span class="hljs-comment">//这里的j是为了遍历每一层的子结点</span><br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; j &lt; dir.<span class="hljs-property">length</span>; ++j) &#123;<br>        <span class="hljs-keyword">if</span> (dir[j].<span class="hljs-property">name</span> == <span class="hljs-variable language_">this</span>.<span class="hljs-property">cur_path</span>[i] &amp;&amp; dir[j].<span class="hljs-property">type</span> != <span class="hljs-number">1</span>) &#123;<br>          <span class="hljs-comment">//一定可以找到一个结点</span><br>          dir = dir[j].<span class="hljs-property">children</span>; <span class="hljs-comment">//dir定位到前一层</span><br>        &#125;<br>      &#125;<br>    &#125;<br>    <span class="hljs-comment">//查询当前层哪个结点为要添加结点的父节点</span><br>    <span class="hljs-keyword">let</span> index = -<span class="hljs-number">1</span>;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">222222</span>);<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(dir);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; dir.<span class="hljs-property">length</span>; ++i) &#123;<br>      <span class="hljs-keyword">if</span> (<br>        dir[i].<span class="hljs-property">name</span> == <span class="hljs-variable language_">this</span>.<span class="hljs-property">cur_path</span>[<span class="hljs-variable language_">this</span>.<span class="hljs-property">cur_path</span>.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>] &amp;&amp;<br>        (dir[i].<span class="hljs-property">type</span> == <span class="hljs-number">2</span> || dir[i].<span class="hljs-property">type</span> == <span class="hljs-number">0</span>)<br>      ) &#123;<br>        index = i;<br>      &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><ol start="2"><li>检查文件名是否冲突及合法性（同一目录下已存在同类型同名文件）<ol><li>若非法则输出提示，等待新的文件名输入</li><li>若合法则进行下一步</li></ol></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//检测名字合法性</span><br>      <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">new_doc_name</span> == <span class="hljs-string">&quot;&quot;</span>) &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">new_doc_type</span> == <span class="hljs-number">0</span>) &#123;<br>          <span class="hljs-title class_">ElMessage</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&quot;文件夹名不能为空！&quot;</span>);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>          <span class="hljs-title class_">ElMessage</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&quot;文件名不能为空！&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span>;<br>      &#125;<br>      <span class="hljs-comment">//检测是否重名</span><br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; dir[index].<span class="hljs-property">children</span>.<span class="hljs-property">length</span>; ++i) &#123;<br>        <span class="hljs-keyword">if</span> (<br>          dir[index].<span class="hljs-property">children</span>[i].<span class="hljs-property">name</span> == <span class="hljs-variable language_">this</span>.<span class="hljs-property">new_doc_name</span> &amp;&amp;<br>          dir[index].<span class="hljs-property">children</span>[i].<span class="hljs-property">type</span> == <span class="hljs-variable language_">this</span>.<span class="hljs-property">new_doc_type</span><br>        ) &#123;<br>          <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">new_doc_type</span> == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-title class_">ElMessage</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&quot;已存在同名文件夹！&quot;</span>);<br>          &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-title class_">ElMessage</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&quot;已存在同名文件！&quot;</span>);<br>          &#125;<br>          <span class="hljs-variable language_">this</span>.<span class="hljs-property">new_doc_name</span> = <span class="hljs-string">&quot;&quot;</span>;<br>          <span class="hljs-variable language_">this</span>.<span class="hljs-property">new_doc_type</span> = -<span class="hljs-number">1</span>;<br>          <span class="hljs-keyword">return</span>;<br>        &#125;<br>      &#125;<br></code></pre></td></tr></table></figure><ol start="3"><li>生成文件其他信息，在文件目录下创建相应FCB</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//生成文件路径</span><br>      <span class="hljs-keyword">let</span> new_doc_path = <span class="hljs-string">&quot;&quot;</span>;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-variable language_">this</span>.<span class="hljs-property">cur_path</span>.<span class="hljs-property">length</span>; ++i) &#123;<br>        new_doc_path += <span class="hljs-variable language_">this</span>.<span class="hljs-property">cur_path</span>[i] + <span class="hljs-string">&quot;\\&quot;</span>;<br>      &#125;<br>      <span class="hljs-keyword">let</span> doc_size = <span class="hljs-number">0</span>;<br>      <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">new_doc_type</span> == <span class="hljs-number">0</span>) &#123;<br>        doc_size = <span class="hljs-string">&quot;-&quot;</span>;<br>      &#125;<br>      dir[index].<span class="hljs-property">children</span>.<span class="hljs-title function_">push</span>(&#123;<br>        <span class="hljs-attr">name</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">new_doc_name</span>,<br>        <span class="hljs-attr">last_edit_timestr</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">new_doc_timestr</span>,<br>        <span class="hljs-attr">last_edit_time</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">new_doc_time</span>,<br>        <span class="hljs-attr">type</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">new_doc_type</span>,<br>        <span class="hljs-attr">size</span>: doc_size,<br>        <span class="hljs-attr">path</span>: new_doc_path,<br>        <span class="hljs-attr">children</span>: [],<br>        <span class="hljs-attr">p_begin</span>: -<span class="hljs-number">1</span>, <span class="hljs-comment">//非文件类型不需要设置此项</span><br>        <span class="hljs-attr">p_end</span>: -<span class="hljs-number">1</span>, <span class="hljs-comment">//非文件类型不需要设置此项</span><br>      &#125;);<br>      dir[index].<span class="hljs-property">last_edit_timestr</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">new_doc_timestr</span>;<br>      dir[index].<span class="hljs-property">last_edit_time</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">new_doc_time</span>;<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">cur_dir</span> = [].<span class="hljs-title function_">concat</span>(dir[index].<span class="hljs-property">children</span>); <span class="hljs-comment">//更新当前目录</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-title function_">alert</span>(<span class="hljs-string">&quot;下标查找有问题&quot;</span>);<br>      <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">new_doc_name</span> = <span class="hljs-string">&quot;&quot;</span>;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">new_doc_type</span> = -<span class="hljs-number">1</span>;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">show_dialog</span> = <span class="hljs-literal">false</span>;<br>    <span class="hljs-title class_">ElMessage</span>(&#123;<br>      <span class="hljs-attr">message</span>: <span class="hljs-string">&quot;创建成功！&quot;</span>,<br>      <span class="hljs-attr">type</span>: <span class="hljs-string">&quot;success&quot;</span>,<br>    &#125;);<br>    <span class="hljs-keyword">return</span>;<br>  &#125;,<br></code></pre></td></tr></table></figure><ol start="4"><li>创建成功（P.S windows 11文件管理系统不会在创建文件时要求输入文本内容，因此此处也不要求，初始化文件大小均为 0 KB）</li></ol><h4 id="打开文件"><a href="#打开文件" class="headerlink" title="打开文件"></a>打开文件</h4><p>根据前端传入的打开文件名称，查找文件目录表，根据其对应的 p_begin，p_end 指针从”外部磁盘”中读取数据</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title function_">openFile</span>(<span class="hljs-params">index</span>) &#123;<br>     <span class="hljs-variable language_">this</span>.<span class="hljs-property">open_doc_name</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">cur_dir</span>[index].<span class="hljs-property">name</span>;<br>     <span class="hljs-variable language_">this</span>.<span class="hljs-property">open_doc_index</span> = index;<br>     <span class="hljs-variable language_">this</span>.<span class="hljs-property">show_content</span> = <span class="hljs-literal">true</span>;<br>     <span class="hljs-variable language_">this</span>.<span class="hljs-property">open_doc_content</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">readDisk</span>(<br>       <span class="hljs-variable language_">this</span>.<span class="hljs-property">cur_dir</span>[index].<span class="hljs-property">p_begin</span>,<br>       <span class="hljs-variable language_">this</span>.<span class="hljs-property">cur_dir</span>[index].<span class="hljs-property">p_end</span><br>     );<br>   &#125;,<br></code></pre></td></tr></table></figure><p>由于打开文件事件由鼠标双击触发，因此此处传入的文件名称必然合法，且一定在 FCB 中存在（若不存在则不会显示在页面上，自然   无法被点击），因此无需检测文件名</p><p>下面介绍 readDisk() 函数，其主要功能为根据文件块指针从“磁盘”读取数据</p><p>判断 p_begin 是否为 -1 ，若为 -1 则说明是一个空文件，直接返回即可；若不为 -1，则从起始块读数据，依据起始块中的指向下一块的指针找到下一块……直至读取完毕，即 p_begin 与 p_end 相等</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//从磁盘中读出数据</span><br>  <span class="hljs-title function_">readDisk</span>(<span class="hljs-params">p_begin, p_end</span>) &#123;<br>    <span class="hljs-keyword">if</span> (p_begin == -<span class="hljs-number">1</span>) &#123;<br>      <span class="hljs-comment">//说明为新文件</span><br>      <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">let</span> content = <span class="hljs-string">&quot;&quot;</span>;<br><br>    <span class="hljs-keyword">let</span> p_cur = p_begin;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>      content += <span class="hljs-variable language_">this</span>.<span class="hljs-property">physical_disk</span>[p_cur].<span class="hljs-property">content</span>;<br>      <span class="hljs-keyword">if</span> (p_cur == p_end) &#123;<br>        <span class="hljs-keyword">break</span>;<br>      &#125;<br>      p_cur = <span class="hljs-variable language_">this</span>.<span class="hljs-property">physical_disk</span>[p_cur].<span class="hljs-property">disk_next</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> content;<br>  &#125;,<br></code></pre></td></tr></table></figure><h4 id="保存文件"><a href="#保存文件" class="headerlink" title="保存文件"></a>保存文件</h4><p>将文件数据存入磁盘，若磁盘有剩余空间则返回 true，记录相关信息并输出提示；若无剩余空间则输出提示，等待文本内容修改</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title function_">saveDoc</span>(<span class="hljs-params"></span>) &#123;<br>     <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-title function_">writeOutDisk</span>()) &#123;<br>       <span class="hljs-comment">//存储至“磁盘”——若成功则返回true，空间不足则返回false</span><br>       <span class="hljs-variable language_">this</span>.<span class="hljs-property">cur_dir</span>[<span class="hljs-variable language_">this</span>.<span class="hljs-property">open_doc_index</span>].<span class="hljs-property">size</span> =<br>         <span class="hljs-variable language_">this</span>.<span class="hljs-property">open_doc_content</span>.<span class="hljs-property">length</span> / <span class="hljs-number">1024</span>;<br>       <span class="hljs-keyword">let</span> a = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>().<span class="hljs-title function_">toLocaleDateString</span>();<br>       <span class="hljs-variable language_">this</span>.<span class="hljs-property">cur_dir</span>[<span class="hljs-variable language_">this</span>.<span class="hljs-property">open_doc_index</span>].<span class="hljs-property">last_edit_time</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>(a) / <span class="hljs-number">1000</span>;<br>       <span class="hljs-variable language_">this</span>.<span class="hljs-property">cur_dir</span>[<span class="hljs-variable language_">this</span>.<span class="hljs-property">open_doc_index</span>].<span class="hljs-property">last_edit_timestr</span> = a;<br>       <span class="hljs-title class_">ElMessage</span>(&#123;<br>         <span class="hljs-attr">message</span>: <span class="hljs-string">&quot;更改已保存！&quot;</span>,<br>         <span class="hljs-attr">type</span>: <span class="hljs-string">&quot;success&quot;</span>,<br>       &#125;);<br>       <span class="hljs-variable language_">this</span>.<span class="hljs-property">show_content</span> = <span class="hljs-literal">false</span>;<br>     &#125; <span class="hljs-keyword">else</span> &#123;<br>       <span class="hljs-title class_">ElMessage</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&quot;磁盘空间不足！&quot;</span>);<br>     &#125;<br>   &#125;,<br></code></pre></td></tr></table></figure><p>下面主要介绍下writeOutDisk()函数，其主要功能为根据文件块指针从“磁盘”读取数据</p><ol><li>查看 p_begin 是否为-1，若为-1则说明该文件之前在磁盘上没有存储的数据，则直接进行第 3 步</li><li>若 p_begin 不为-1，则说明该文件之前在磁盘上存储有数据。此处设计为将磁盘上该文件的旧数据擦除，再存储新数据</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">cur_dir</span>[<span class="hljs-variable language_">this</span>.<span class="hljs-property">open_doc_index</span>].<span class="hljs-property">p_begin</span> != -<span class="hljs-number">1</span>) &#123;<br>      <span class="hljs-comment">//说明不是第一次写 则删除</span><br>      <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">deleteFromDisk</span>(<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">cur_dir</span>[<span class="hljs-variable language_">this</span>.<span class="hljs-property">open_doc_index</span>].<span class="hljs-property">p_begin</span>,<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">cur_dir</span>[<span class="hljs-variable language_">this</span>.<span class="hljs-property">open_doc_index</span>].<span class="hljs-property">p_end</span><br>      );<br>      <span class="hljs-comment">//修改目录项</span><br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">cur_dir</span>[<span class="hljs-variable language_">this</span>.<span class="hljs-property">open_doc_index</span>].<span class="hljs-property">p_begin</span> = -<span class="hljs-number">1</span>;<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">cur_dir</span>[<span class="hljs-variable language_">this</span>.<span class="hljs-property">open_doc_index</span>].<span class="hljs-property">p_end</span> = -<span class="hljs-number">1</span>;<br>  &#125;<br></code></pre></td></tr></table></figure><ol start="3"><li>计算保存的数据所需要的磁盘块数，并将数据按块大小分隔成相应份</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> size = <span class="hljs-variable language_">this</span>.<span class="hljs-property">open_doc_content</span>.<span class="hljs-property">length</span>; <span class="hljs-comment">//假设1个字符占1个字节</span><br>   <span class="hljs-keyword">let</span> block_size = <span class="hljs-variable language_">this</span>.<span class="hljs-property">disk_bitmap</span>[<span class="hljs-number">0</span>].<span class="hljs-property">bolck_size</span>;<br>   <span class="hljs-keyword">let</span> block_need_num = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">ceil</span>(size / block_size);<br>   <span class="hljs-keyword">var</span> block_content_ary = []; <span class="hljs-comment">//将字符串按块能存储的最大长度切割，子串存至数组中</span><br>   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-variable language_">this</span>.<span class="hljs-property">open_doc_content</span>.<span class="hljs-property">length</span>; i += block_size) &#123;<br>     block_content_ary.<span class="hljs-title function_">push</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">open_doc_content</span>.<span class="hljs-title function_">slice</span>(i, i + block_size));<br>   &#125;<br></code></pre></td></tr></table></figure><ol start="4"><li>通过位图磁盘是否有剩余空间，若不足，则返回 false 输出提示并等待文本内容修改；若充足则进行磁盘块空间分配。分配规则为通过位图寻找前N个（假设需要 N 块）空闲块，依次将数据存入，并建立块指针链接。完成后返回 true</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//判断空间是否充足</span><br>   <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">disk_bitmap</span>[<span class="hljs-number">0</span>].<span class="hljs-property">block_free_num</span> &gt;= block_need_num) &#123;<br>     <span class="hljs-variable language_">this</span>.<span class="hljs-property">disk_bitmap</span>[<span class="hljs-number">0</span>].<span class="hljs-property">block_free_num</span> -= block_need_num; <span class="hljs-comment">//修改空闲块数</span><br>     <span class="hljs-comment">//分配空间</span><br>     <span class="hljs-keyword">let</span> count = <span class="hljs-number">0</span>; <span class="hljs-comment">//计数</span><br>     <span class="hljs-keyword">let</span> last_block_index = -<span class="hljs-number">1</span>; <span class="hljs-comment">//记录上一个</span><br>     <span class="hljs-keyword">let</span> bitmap_change_index = [];<br>     <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i <span class="hljs-keyword">in</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">disk_bitmap</span>[<span class="hljs-number">0</span>].<span class="hljs-property">bitmap</span>) &#123;<br>       <span class="hljs-keyword">if</span> (count == block_need_num) &#123;<br>         <span class="hljs-variable language_">this</span>.<span class="hljs-property">cur_dir</span>[<span class="hljs-variable language_">this</span>.<span class="hljs-property">open_doc_index</span>].<span class="hljs-property">p_end</span> = last_block_index; <span class="hljs-comment">//记录终止指针</span><br>         <span class="hljs-keyword">break</span>;<br>       &#125;<br>       <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">disk_bitmap</span>[<span class="hljs-number">0</span>].<span class="hljs-property">bitmap</span>[i] == <span class="hljs-string">&quot;0&quot;</span>) &#123;<br>         <span class="hljs-keyword">if</span> (count == <span class="hljs-number">0</span>) &#123;<br>           <span class="hljs-variable language_">this</span>.<span class="hljs-property">cur_dir</span>[<span class="hljs-variable language_">this</span>.<span class="hljs-property">open_doc_index</span>].<span class="hljs-property">p_begin</span> = i; <span class="hljs-comment">//记录起始指针</span><br>           bitmap_change_index.<span class="hljs-title function_">push</span>(i); <span class="hljs-comment">//记录位图</span><br>           <span class="hljs-variable language_">this</span>.<span class="hljs-property">physical_disk</span>[i].<span class="hljs-property">content</span> = block_content_ary[count]; <span class="hljs-comment">//存入外部磁盘</span><br>           <span class="hljs-variable language_">this</span>.<span class="hljs-property">physical_disk</span>[i].<span class="hljs-property">des_content</span> = block_content_ary[<br>             count<br>           ].<span class="hljs-title function_">slice</span>(<span class="hljs-number">0</span>, <span class="hljs-number">10</span>);<br>           count++;<br>           last_block_index = i; <span class="hljs-comment">//记录</span><br>         &#125; <span class="hljs-keyword">else</span> &#123;<br>           <span class="hljs-variable language_">this</span>.<span class="hljs-property">physical_disk</span>[last_block_index].<span class="hljs-property">disk_next</span> = i; <span class="hljs-comment">//上一个磁盘块指向此块</span><br>           bitmap_change_index.<span class="hljs-title function_">push</span>(i); <span class="hljs-comment">//记录位图</span><br>           <span class="hljs-variable language_">this</span>.<span class="hljs-property">physical_disk</span>[i].<span class="hljs-property">content</span> = block_content_ary[count]; <span class="hljs-comment">//存入外部磁盘</span><br>           <span class="hljs-variable language_">this</span>.<span class="hljs-property">physical_disk</span>[i].<span class="hljs-property">des_content</span> = block_content_ary[<br>             count<br>           ].<span class="hljs-title function_">slice</span>(<span class="hljs-number">0</span>, <span class="hljs-number">10</span>);<br>           count++;<br>           last_block_index = i; <span class="hljs-comment">//记录</span><br>         &#125;<br>       &#125;<br>     &#125;<br>     ...<br></code></pre></td></tr></table></figure><h4 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h4><ol><li>由于文件目录以多级目录方式组织，因此直接遍历树找到当前目录下要删除的文件所属的直接父文件夹及删除过程中所需参数</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/*确定delete_index，delete_cur_path,delete_cur_dir*/</span><br><span class="hljs-keyword">let</span> delete_cur_path = delete_doc_path.<span class="hljs-title function_">split</span>(<span class="hljs-string">&quot;\\&quot;</span>); <span class="hljs-comment">//转为数组</span><br>delete_cur_path.<span class="hljs-title function_">pop</span>();<br><span class="hljs-keyword">let</span> dir = <span class="hljs-variable language_">this</span>.<span class="hljs-property">totol_dir</span>; <span class="hljs-comment">//保存当前层的情况</span><br><span class="hljs-comment">//这里的i相当于深度</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; delete_cur_path.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>; ++i) &#123;<br>  <span class="hljs-comment">//这里的j是为了遍历每一层的子结点</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; j &lt; dir.<span class="hljs-property">length</span>; ++j) &#123;<br>    <span class="hljs-keyword">if</span> (dir[j].<span class="hljs-property">name</span> == delete_cur_path[i] &amp;&amp; dir[j].<span class="hljs-property">type</span> != <span class="hljs-number">1</span>) &#123;<br>      <span class="hljs-comment">//一定可以找到一个结点</span><br>      dir = dir[j].<span class="hljs-property">children</span>; <span class="hljs-comment">//dir定位到前一层</span><br>    &#125;<br>  &#125;<br>&#125;<br><span class="hljs-comment">//查询当前层哪个结点为要删除结点的父节点</span><br><span class="hljs-keyword">let</span> index = -<span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; dir.<span class="hljs-property">length</span>; ++i) &#123;<br>  <span class="hljs-keyword">if</span> (<br>    dir[i].<span class="hljs-property">name</span> == delete_cur_path[delete_cur_path.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>] &amp;&amp;<br>    dir[i].<span class="hljs-property">type</span> != <span class="hljs-number">1</span><br>  ) &#123;<br>    index = i;<br>  &#125;<br>&#125;<br><span class="hljs-keyword">let</span> delete_cur_dir = [].<span class="hljs-title function_">concat</span>(dir[index].<span class="hljs-property">children</span>); <span class="hljs-comment">//确定cur_dir</span><br><span class="hljs-keyword">if</span> (index == -<span class="hljs-number">1</span>) &#123;<br>  <span class="hljs-title function_">alert</span>(-<span class="hljs-number">1</span>);<br>  <span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-keyword">let</span> delete_index = -<span class="hljs-number">1</span>;<br><span class="hljs-comment">//确定selected_index</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; delete_cur_dir.<span class="hljs-property">length</span>; ++i) &#123;<br>  <span class="hljs-keyword">if</span> (<br>    delete_cur_dir[i].<span class="hljs-property">name</span> == delete_doc_name &amp;&amp;<br>    delete_cur_dir[i].<span class="hljs-property">type</span> == type<br>  ) &#123;<br>    delete_index = i;<br>    <span class="hljs-keyword">break</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li><p>判断删除的文件类型</p><p>若不为文件夹，且在磁盘内存有数据（p_begin 不为-1），则先根据文件目录表中 FCB 所记录的块指针，调用<code> deleteFromDisk(p_begin,p_end)</code>将磁盘对应块中的数据擦除，并取消块之间的链接</p></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">if</span> (delete_cur_dir[delete_index].<span class="hljs-property">p_begin</span> != -<span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">deleteFromDisk</span>(<br>          delete_cur_dir[delete_index].<span class="hljs-property">p_begin</span>,<br>          delete_cur_dir[delete_index].<span class="hljs-property">p_end</span><br>        );<br>      &#125;<br></code></pre></td></tr></table></figure><p>​在从对应的文件目录中将对应的 FCB 项去除，即从树中去除相应结点</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; dir[index].<span class="hljs-property">children</span>.<span class="hljs-property">length</span>; ++i) &#123;<br>        <span class="hljs-keyword">if</span> (<br>          dir[index].<span class="hljs-property">children</span>[i].<span class="hljs-property">name</span> == delete_cur_dir[delete_index].<span class="hljs-property">name</span> &amp;&amp;<br>          dir[index].<span class="hljs-property">children</span>[i].<span class="hljs-property">type</span> == delete_cur_dir[delete_index].<span class="hljs-property">type</span><br>        ) &#123;<br>          dir[index].<span class="hljs-property">children</span>.<span class="hljs-title function_">splice</span>(i, <span class="hljs-number">1</span>);<br>          <span class="hljs-variable language_">this</span>.<span class="hljs-property">cur_dir</span> = [].<span class="hljs-title function_">concat</span>(dir[index].<span class="hljs-property">children</span>); <span class="hljs-comment">//更新目录</span><br>          <span class="hljs-keyword">return</span>;<br>        &#125;<br>      &#125;<br></code></pre></td></tr></table></figure><pre><code class="hljs">      若为文件夹，则递归调用本函数，将所有的子文件删除后，再将其删除</code></pre><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs javascript">...<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (type == <span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-comment">//删除文件夹</span><br>      <span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>;<br>      <span class="hljs-keyword">while</span> (i &lt; delete_cur_dir[delete_index].<span class="hljs-property">children</span>.<span class="hljs-property">length</span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">deleteFile</span>(<br>          delete_cur_dir[delete_index].<span class="hljs-property">children</span>[<span class="hljs-number">0</span>].<span class="hljs-property">type</span>,<br>          delete_cur_dir[delete_index].<span class="hljs-property">children</span>[<span class="hljs-number">0</span>].<span class="hljs-property">path</span>,<br>          delete_cur_dir[delete_index].<span class="hljs-property">children</span>[<span class="hljs-number">0</span>].<span class="hljs-property">name</span><br>        );<br>      &#125;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; dir[index].<span class="hljs-property">children</span>.<span class="hljs-property">length</span>; ++i) &#123;<br>        <span class="hljs-keyword">if</span> (<br>          dir[index].<span class="hljs-property">children</span>[i].<span class="hljs-property">name</span> == delete_doc_name &amp;&amp;<br>          dir[index].<span class="hljs-property">children</span>[i].<span class="hljs-property">type</span> == <span class="hljs-number">0</span><br>        ) &#123;<br>          dir[index].<span class="hljs-property">children</span>.<span class="hljs-title function_">splice</span>(i, <span class="hljs-number">1</span>);<br>          <span class="hljs-variable language_">this</span>.<span class="hljs-property">cur_dir</span> = [].<span class="hljs-title function_">concat</span>(dir[index].<span class="hljs-property">children</span>);<br><br>          <span class="hljs-keyword">break</span>;<br>        &#125;<br>      &#125;<br>      <span class="hljs-keyword">return</span>;<br>    &#125;<br></code></pre></td></tr></table></figure><h4 id="数据记录-x2F-恢复"><a href="#数据记录-x2F-恢复" class="headerlink" title="数据记录&#x2F;恢复"></a>数据记录&#x2F;恢复</h4><p>使用 <strong>localStorage</strong> 对象，其允许在浏览器中存储 key&#x2F;value 对的数据，可长久保存整个网站的数据，保存的数据没有过期时间，直到手动去删除，所以很适合在本项目使用</p><h5 id="保存数据"><a href="#保存数据" class="headerlink" title="保存数据"></a>保存数据</h5><p>在页面关闭&#x2F;刷新&#x2F;前进&#x2F;后退时，将文件目录表、位图、用内存空间模拟的磁盘空间数据转换为 JSON 格式，存入缓存中。需要在 mounted 钩子中设置</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title function_">mounted</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-comment">//浏览器退出时存储</span><br>    <span class="hljs-variable language_">window</span>.<span class="hljs-property">onbeforeunload</span> = <span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> &#123;<br>      e = e || <span class="hljs-variable language_">window</span>.<span class="hljs-property">event</span>;<br>      <span class="hljs-keyword">if</span> (e) &#123;<br>        e.<span class="hljs-property">returnValue</span> = <span class="hljs-string">&quot;关闭提示&quot;</span>;<br>      &#125;<br>      <span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">clear</span>();<br>      <span class="hljs-keyword">let</span> physical_disk_JSON = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">physical_disk</span>);<br>      <span class="hljs-keyword">let</span> totol_dir_JSON = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">totol_dir</span>);<br>      <span class="hljs-keyword">let</span> disk_bitmap_JSON = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">disk_bitmap</span>);<br>      <span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">setItem</span>(<span class="hljs-string">&quot;physical_disk&quot;</span>, physical_disk_JSON);<br>      <span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">setItem</span>(<span class="hljs-string">&quot;total_dir&quot;</span>, totol_dir_JSON);<br>      <span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">setItem</span>(<span class="hljs-string">&quot;disk_bitmap&quot;</span>, disk_bitmap_JSON);<br>      <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;关闭提示&quot;</span>;<br>    &#125;;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="读取数据"><a href="#读取数据" class="headerlink" title="读取数据"></a>读取数据</h5><p>在页面打开后，变量创建完成但页面未渲染时，检测本地缓存中是否有相应数据，若有则读取数据，将读到的 JSON 格式转换回对象，完成相应状态的恢复。在created 钩子设置：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title function_">created</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">physicalDiskInit</span>(); <span class="hljs-comment">//初始化硬盘</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">localStorage</span>.<span class="hljs-property">length</span> != <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">totol_dir</span> = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(<span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">getItem</span>(<span class="hljs-string">&quot;total_dir&quot;</span>));<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">physical_disk</span> = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(<span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">getItem</span>(<span class="hljs-string">&quot;physical_disk&quot;</span>));<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">disk_bitmap</span> = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(<span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">getItem</span>(<span class="hljs-string">&quot;disk_bitmap&quot;</span>));<br>  &#125;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">cur_dir</span> = [];<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">cur_dir</span>.<span class="hljs-title function_">push</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">totol_dir</span>[<span class="hljs-number">0</span>]); <span class="hljs-comment">//初始化当前目录</span><br>&#125;,<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>课程项目分享</category>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
      <tag>文件管理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>内存管理-OS课程项目</title>
    <link href="/2022/06/03/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86-OS%E8%AF%BE%E7%A8%8B%E9%A1%B9%E7%9B%AE/"/>
    <url>/2022/06/03/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86-OS%E8%AF%BE%E7%A8%8B%E9%A1%B9%E7%9B%AE/</url>
    
    <content type="html"><![CDATA[<h1 id="内存管理——请求调页存储管理方式模拟"><a href="#内存管理——请求调页存储管理方式模拟" class="headerlink" title="内存管理——请求调页存储管理方式模拟"></a>内存管理——请求调页存储管理方式模拟</h1><p>[TOC]</p><h3 id="开发环境"><a href="#开发环境" class="headerlink" title="开发环境"></a>开发环境</h3><p>开发语言：Javascript+html+css</p><p>开发框架：Vue.js 3.0+Element-plus</p><p>开发工具：Vue-cli、Vue-devtools、VScode、Edge</p><h3 id="实现方法"><a href="#实现方法" class="headerlink" title="实现方法"></a>实现方法</h3><p>引入Element-plus组件作为UI，采用Vue3框架进行组件化开发</p><p>采用 JS 模拟内存管理调页请求逻辑，使用 Vue3 开发单页面应用，便于实时渲染、信息实时显示</p><p>使用链表来辅助实现LRU算法</p><h3 id="项目浏览"><a href="#项目浏览" class="headerlink" title="项目浏览"></a>项目浏览</h3><ul><li>联网进入<a href="https://pikachudy.github.io/MemoryScheduling/">MemoryScheduling (pikachudy.github.io)</a>在线浏览</li></ul><h3 id="界面UI说明"><a href="#界面UI说明" class="headerlink" title="界面UI说明"></a>界面UI说明</h3><ul><li><p>左栏：</p><ul><li><p>上部分为内存块信息，包含块序号、块内存放页的页号（若没有则为 null）、块起始地址（每次重置时随机给出）</p></li><li><p>中间为当前已执行指令条数、当前缺页数、当前缺页率</p></li><li><p>下部分为调页信息表，记录了目前为止每次调度的相关信息，包括调入的逻辑页、调至的块号、被替换出的逻辑页（若无则为 null）</p></li><li><p>支持滚动条滚动翻阅所有信息</p></li></ul></li><li><p>右栏：</p><ul><li>记录每次指令执行的相关信息，包括指令id、指令位于的逻辑页号、包含指令的页当前在那一块内存块中（若不在内存中则为 null）、指令在内存中的地址（若不在内存中则为 null ），下一条指令的 id</li><li>当指令不在内存中时，会<strong>先显示指令缺页信息</strong>，在缺页请求调度完成后，会<strong>再次打印本条指令</strong>调度后信息</li><li>支持滚动条滚动翻阅所有信息</li></ul></li><li><p>顶栏：</p><ul><li>单步执行按钮：点击后执行一条指令，若发生缺页则完成缺页请求调度后<strong>再次打印本条指令信息</strong></li><li>自动执行按钮：通过右侧输入框设置合适的指令执行速度，点击自动执行按钮，会根据设置的执行速度自动执行指令，直到单击重置按钮或320条指令全部执行完毕</li><li>重置按钮：点击后恢复到初始状态</li></ul></li></ul><h3 id="源码文件功能介绍"><a href="#源码文件功能介绍" class="headerlink" title="源码文件功能介绍"></a>源码文件功能介绍</h3><p>本次的页面较为简单，实现功能的主要文件为<strong>Pageshow.vue</strong>及<strong>linklist.js</strong></p><h4 id="文件预览"><a href="#文件预览" class="headerlink" title="文件预览"></a>文件预览</h4><table><thead><tr><th>文件名称</th><th>负责内容</th><th>子组件</th></tr></thead><tbody><tr><td>App.vue</td><td>页面根组件</td><td>PageShow.vue</td></tr><tr><td>PageShow.vue</td><td>实现页面UI展示、整体逻辑</td><td>null</td></tr><tr><td>linklist.js</td><td>实现链表数据结构，便于实现LRU算法</td><td>-</td></tr></tbody></table><h4 id="主要文件源码变量介绍"><a href="#主要文件源码变量介绍" class="headerlink" title="主要文件源码变量介绍"></a>主要文件源码变量介绍</h4><h5 id="PageShow-vue"><a href="#PageShow-vue" class="headerlink" title="PageShow.vue"></a>PageShow.vue</h5><h6 id="维护变量"><a href="#维护变量" class="headerlink" title="维护变量"></a>维护变量</h6><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> &#123;<br>      <span class="hljs-attr">run_continuously</span>: <span class="hljs-literal">false</span>, <span class="hljs-comment">//是否自动执行——与按钮相关</span><br>      <span class="hljs-attr">interval</span>: <span class="hljs-number">0.5</span>, <span class="hljs-comment">//自动运行间隔</span><br>      <span class="hljs-attr">timer</span>: <span class="hljs-literal">null</span>, <span class="hljs-comment">//存储定时器返回的对象以控制</span><br><br>      <span class="hljs-attr">exe_num</span>: <span class="hljs-number">0</span>, <span class="hljs-comment">//已执行条数</span><br>      <span class="hljs-attr">page_miss</span>: <span class="hljs-number">0</span>, <span class="hljs-comment">//缺页数</span><br>      <span class="hljs-title class_">LRUlist</span>: <span class="hljs-keyword">new</span> <span class="hljs-title function_">linklist</span>(), <span class="hljs-comment">//LRU算法辅助链表</span><br>      <span class="hljs-attr">exe_order</span>: [], <span class="hljs-comment">//指令执行顺序</span><br>      <span class="hljs-attr">mem_block_num</span>: <span class="hljs-number">4</span>, <span class="hljs-comment">//内存块数</span><br>      <span class="hljs-attr">process_page_num</span>: <span class="hljs-number">32</span>, <span class="hljs-comment">//进程页数</span><br>      <span class="hljs-attr">instruction_num</span>: <span class="hljs-number">320</span>, <span class="hljs-comment">//指令数</span><br>        <br>      <span class="hljs-attr">physical_memory</span>: [], <span class="hljs-comment">//内存信息</span><br>      <span class="hljs-attr">page_table</span>: [], <span class="hljs-comment">//页表信息</span><br>      <span class="hljs-attr">instruction_record</span>: [], <span class="hljs-comment">//指令记录</span><br>      <span class="hljs-attr">schedule_record</span>: [], <span class="hljs-comment">//调度记录</span><br>    &#125;;<br></code></pre></td></tr></table></figure><h6 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h6><p>组件内部维护了请求调页存储管理的所有信息，除了基本的内存块数、进程页数、进程指令总数等参数外，还用了对象数组<strong>physical_memory</strong>, <strong>page_table</strong> 来存储各个内存块信息、页表信息，以此模拟内存管理中相应的数据结构；并设置了<strong>instruction_record</strong> 及<strong>schedule_record</strong> 来记录每次指令执行相关信息、调度相关信息以便于在表格中展示。</p><h6 id="主要对象属性介绍"><a href="#主要对象属性介绍" class="headerlink" title="主要对象属性介绍"></a>主要对象属性介绍</h6><p><strong>physical_memory</strong> 数组中的内存对象包含以下属性：</p><ul><li>id：内存块号</li><li>start_addr:  起始地址</li><li>length：内存地址长度——<strong>以一个指令长为单位</strong></li><li>content：内存块中存放的信息的逻辑页号，若无则为 null</li></ul><p>初始化函数代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title function_">memory_init</span>(<span class="hljs-params"></span>) &#123;<br>     <span class="hljs-keyword">let</span> start = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>() * <span class="hljs-number">5</span>); <span class="hljs-comment">//随机获取0-5的整数</span><br>     <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-variable language_">this</span>.<span class="hljs-property">mem_block_num</span>; ++i) &#123;<br>       <span class="hljs-variable language_">this</span>.<span class="hljs-property">physical_memory</span>.<span class="hljs-title function_">push</span>(&#123;<br>         <span class="hljs-attr">id</span>: i, <span class="hljs-comment">//内存号</span><br>         <span class="hljs-attr">start_addr</span>: i + start + <span class="hljs-string">&quot;0&quot;</span>,<br>         <span class="hljs-attr">length</span>: <span class="hljs-number">10</span>,<br>         <span class="hljs-attr">content</span>: <span class="hljs-string">&quot;null&quot;</span>, <span class="hljs-comment">//内存块存放内容</span><br>       &#125;);<br>     &#125;<br>   &#125;,<br></code></pre></td></tr></table></figure><p><strong>page_table</strong> 数组中的各个页信息包含以下属性：</p><ul><li>id：逻辑页号</li><li>valid：有效位——标识是否在内存块中</li><li>memory_id：若位于内存块中，则此处记录位于的内存块号，否则为 null</li></ul><p>初始化函数代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title function_">pagetable_init</span>(<span class="hljs-params"></span>) &#123;<br>     <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-variable language_">this</span>.<span class="hljs-property">process_page_num</span>; ++i) &#123;<br>       <span class="hljs-variable language_">this</span>.<span class="hljs-property">page_table</span>.<span class="hljs-title function_">push</span>(&#123;<br>         <span class="hljs-attr">id</span>: i, <span class="hljs-comment">//逻辑页号</span><br>         <span class="hljs-attr">valid</span>: <span class="hljs-literal">false</span>, <span class="hljs-comment">//是否有效——是否在内存中</span><br>         <span class="hljs-attr">memory_id</span>: <span class="hljs-literal">null</span>, <span class="hljs-comment">//位于主存块号</span><br>       &#125;);<br>     &#125;<br>   &#125;,<br></code></pre></td></tr></table></figure><h5 id="linklist-js"><a href="#linklist-js" class="headerlink" title="linklist.js"></a>linklist.js</h5><h6 id="主要变量"><a href="#主要变量" class="headerlink" title="主要变量"></a>主要变量</h6><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">linklist</span> &#123;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">item</span> = <span class="hljs-number">0</span>; <span class="hljs-comment">//头结点显示当前列表长度</span><br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">next</span> = <span class="hljs-literal">null</span>;<br>    &#125;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="主要成员函数（方法）"><a href="#主要成员函数（方法）" class="headerlink" title="主要成员函数（方法）"></a>主要成员函数（方法）</h6><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">linklist</span> &#123;<br>    ...<br>    <span class="hljs-comment">//在链表末尾添加结点</span><br>    <span class="hljs-title function_">append</span>(<span class="hljs-params">item</span>) &#123;<br>       ...<br>    &#125;<br>    <span class="hljs-comment">//删除链表末尾结点——返回被删除的结点的内容</span><br>    <span class="hljs-title function_">deleteLast</span>(<span class="hljs-params"></span>) &#123;<br>       ...<br>    &#125;<br>    <span class="hljs-comment">//寻找元素是否在链表中，若存在则返回相应位置（头结点位置为0），若不存在则返回-1</span><br>    <span class="hljs-title function_">findIndex</span>(<span class="hljs-params">item</span>) &#123;<br>       ...<br>    &#125;<br>    <span class="hljs-comment">//将指定位置元素移至链表头（头结点后第一个）——成功返回true，失败返回false</span><br>    <span class="hljs-title function_">movetoHead</span>(<span class="hljs-params">index</span>) &#123;<br>       ...<br>    &#125;<br>    <span class="hljs-comment">//在链表首位插入元素</span><br>    <span class="hljs-title function_">insertHead</span>(<span class="hljs-params">item</span>) &#123;<br>       ...<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="算法设计及实现"><a href="#算法设计及实现" class="headerlink" title="算法设计及实现"></a>算法设计及实现</h3><h4 id="随机指令生成算法"><a href="#随机指令生成算法" class="headerlink" title="随机指令生成算法"></a>随机指令生成算法</h4><p>设指令id为0-319，共320条：</p><ol><li><p>在<strong>0－318</strong>条指令之间，随机选取一个起始执行指令，如序号为m</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> randomOrder = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>() * (<span class="hljs-variable language_">this</span>.<span class="hljs-property">instruction_num</span> - <span class="hljs-number">1</span>)); <span class="hljs-comment">//随机选取起始执行指令</span><br>     <span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>;<br>     <span class="hljs-variable language_">this</span>.<span class="hljs-property">exe_order</span>.<span class="hljs-title function_">push</span>(randomOrder);<br>     i++;<br></code></pre></td></tr></table></figure></li><li><p>顺序执行下一条指令，即序号为<strong>m+1</strong>的指令</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">this</span>.<span class="hljs-property">exe_order</span>.<span class="hljs-title function_">push</span>(randomOrder + <span class="hljs-number">1</span>); <span class="hljs-comment">//执行序号+1的指令</span><br>   i++;<br></code></pre></td></tr></table></figure></li><li><p>通过随机数，跳转到前地址部分<strong>0－m-1</strong>中的某个指令处，其序号为<strong>m<del>1</del></strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript">randomOrder = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>() * randomOrder); <span class="hljs-comment">//跳转至前0 - m-1</span><br>   <span class="hljs-variable language_">this</span>.<span class="hljs-property">exe_order</span>.<span class="hljs-title function_">push</span>(randomOrder);<br>   i++;<br></code></pre></td></tr></table></figure></li><li><p>顺序执行下一条指令，即序号为<strong>m<del>1</del>+1</strong>的指令</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">this</span>.<span class="hljs-property">exe_order</span>.<span class="hljs-title function_">push</span>(randomOrder + <span class="hljs-number">1</span>); <span class="hljs-comment">//执行序号+1的指令</span><br>i++;<br></code></pre></td></tr></table></figure></li><li><p>通过随机数，跳转到后地址部分<strong>m<del>1</del>+2~318</strong>中的某条指令处，其序号为<strong>m<del>2</del></strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript">randomOrder = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(<br>     <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>() * (<span class="hljs-variable language_">this</span>.<span class="hljs-property">instruction_num</span> - randomOrder - <span class="hljs-number">4</span>) + randomOrder + <span class="hljs-number">2</span><br>   ); <span class="hljs-comment">//跳转至后 m+2 - 319</span><br>   <span class="hljs-variable language_">this</span>.<span class="hljs-property">exe_order</span>.<span class="hljs-title function_">push</span>(randomOrder);<br>   i++;<br></code></pre></td></tr></table></figure></li><li><p>顺序执行下一条指令，即<strong>m<del>2</del>+1</strong>处的指令</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">this</span>.<span class="hljs-property">exe_order</span>.<span class="hljs-title function_">push</span>(randomOrder + <span class="hljs-number">1</span>); <span class="hljs-comment">//执行序号+1的指令</span><br>i++;<br></code></pre></td></tr></table></figure></li><li><p>重复跳转到前地址部分、顺序执行、跳转到后地址部分、顺序执行的过程，直到执行完毕</p></li></ol><h4 id="LRU算法"><a href="#LRU算法" class="headerlink" title="LRU算法"></a>LRU算法</h4><p>LRU算法要求替换最近最少使用的块，可以用链表来实现，链表中结点值为<strong>存有页项</strong>的内存块号，相当于一个内存块链表。</p><p>采用以下规则确定根据LRU算法应该被替换出的块：</p><ol><li><p>当访问后未发生缺页时，将访问的页所在的内存块移动至链表首结点处；</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//页表处于内存中</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">LRUlist</span>.<span class="hljs-title function_">movetoHead</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">LRUlist</span>.<span class="hljs-title function_">findIndex</span>(page.<span class="hljs-property">memory_id</span>)); <span class="hljs-comment">//将页表所在块移至链表头</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-title function_">instruct_record_update</span>(insturction_id); <span class="hljs-comment">//更新记录</span><br></code></pre></td></tr></table></figure></li><li><p>当访问后发生了缺页：</p><ol><li><p>若内存块未被占满（即链表长度小于内存总块数），则新建结点，结点值为页刚刚放入的内存块号，并将该结点插至链表顶端；</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">LRUlist</span>.<span class="hljs-title function_">length</span>() &lt; <span class="hljs-variable language_">this</span>.<span class="hljs-property">mem_block_num</span>) &#123;<br>       <span class="hljs-comment">//若内存块中有剩余空间则将该页直接放入内存块，将对应的内存块插至链表首位置</span><br>       <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-variable language_">this</span>.<span class="hljs-property">mem_block_num</span>; ++i) &#123;<br>         <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">physical_memory</span>[i].<span class="hljs-property">content</span> == <span class="hljs-string">&quot;null&quot;</span>) &#123;<br>           <span class="hljs-comment">//将页放入内存</span><br>           <span class="hljs-variable language_">this</span>.<span class="hljs-property">physical_memory</span>[i].<span class="hljs-property">content</span> = page_in.<span class="hljs-property">id</span>;<br>           <span class="hljs-comment">//将内存块号插至链表首位</span><br>           <span class="hljs-variable language_">this</span>.<span class="hljs-property">LRUlist</span>.<span class="hljs-title function_">insertHead</span>(i);<br>           <span class="hljs-keyword">return</span> &#123;<br>             <span class="hljs-attr">page_in</span>: page_in.<span class="hljs-property">id</span>,<br>             <span class="hljs-attr">dst_block</span>: i,<br>             <span class="hljs-attr">page_out</span>: <span class="hljs-string">&quot;null&quot;</span>,<br>           &#125;;<br>         &#125;<br>       &#125;<br>     &#125; <br> ...<br></code></pre></td></tr></table></figure></li><li><p>若内存块已被占满（即链表长度等于内存总块数），则链表末尾的结点对应的内存块应当是要发生替换的块，将其从链表中删除，则转换成了上一种情况；</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript">...<br> <span class="hljs-keyword">else</span> &#123;<br>       <span class="hljs-comment">//若内存中无剩余空间</span><br>       <span class="hljs-keyword">let</span> dst_block_id = <span class="hljs-variable language_">this</span>.<span class="hljs-property">LRUlist</span>.<span class="hljs-title function_">deleteLast</span>(); <span class="hljs-comment">//删除链尾元素，确定替换的块号</span><br>       <span class="hljs-keyword">let</span> page_out_id = <span class="hljs-variable language_">this</span>.<span class="hljs-property">physical_memory</span>[dst_block_id].<span class="hljs-property">content</span>; <span class="hljs-comment">//被调出的页号</span><br>       <span class="hljs-variable language_">this</span>.<span class="hljs-property">physical_memory</span>[dst_block_id].<span class="hljs-property">content</span> = page_in.<span class="hljs-property">id</span>; <span class="hljs-comment">//将新页调入</span><br>       <span class="hljs-comment">//将内存块号插至首位</span><br>       <span class="hljs-variable language_">this</span>.<span class="hljs-property">LRUlist</span>.<span class="hljs-title function_">insertHead</span>(dst_block_id);<br>       <span class="hljs-keyword">return</span> &#123;<br>         <span class="hljs-attr">page_in</span>: page_in.<span class="hljs-property">id</span>,<br>         <span class="hljs-attr">dst_block</span>: dst_block_id,<br>         <span class="hljs-attr">page_out</span>: page_out_id,<br>       &#125;;<br>     &#125;<br></code></pre></td></tr></table></figure></li></ol></li></ol><h4 id="请求调页存储管理算法"><a href="#请求调页存储管理算法" class="headerlink" title="请求调页存储管理算法"></a>请求调页存储管理算法</h4><ol><li><p>在执行一条新指令时，根据其id（逻辑地址）获取其相应的逻辑页号，再通过查询页表获取该页对象，其包含相关信息——是否位于内存中，位于哪一个内存块等</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> insturction_id = <span class="hljs-variable language_">this</span>.<span class="hljs-property">exe_order</span>[<span class="hljs-variable language_">this</span>.<span class="hljs-property">exe_num</span>]; <span class="hljs-comment">//获取对应的指令id</span><br>   <span class="hljs-keyword">let</span> page_id = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(insturction_id / <span class="hljs-number">10</span>); <span class="hljs-comment">//对应页号</span><br>   <span class="hljs-keyword">let</span> page = <span class="hljs-variable language_">this</span>.<span class="hljs-property">page_table</span>[page_id]; <span class="hljs-comment">//获取页表对应项</span><br></code></pre></td></tr></table></figure></li><li><p>判断该页是否位于内存中，即是否发生缺页：</p><ol><li><p>若发生缺页，则根据LRU算法选择被替换块，进行替换、修改页表对应项，并记录相关信息</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">if</span> (page.<span class="hljs-property">valid</span> == <span class="hljs-literal">false</span>) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">instruct_record_update</span>(insturction_id); <span class="hljs-comment">//更新记录</span><br>  <span class="hljs-comment">//若页表不在内存中</span><br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">page_miss</span>++;<br>  <span class="hljs-keyword">let</span> cur_schedule = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">LRU</span>(page); <span class="hljs-comment">//利用LRU算法进行调度，返回调度信息</span><br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">schedule_record</span>.<span class="hljs-title function_">push</span>(cur_schedule); <span class="hljs-comment">//记录调度信息</span><br>  <span class="hljs-comment">//修改页表内容</span><br>  <span class="hljs-comment">//修改调入页信息</span><br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">page_table</span>[page_id].<span class="hljs-property">valid</span> = <span class="hljs-literal">true</span>;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">page_table</span>[page_id].<span class="hljs-property">memory_id</span> = cur_schedule.<span class="hljs-property">dst_block</span>;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">instruct_record_update</span>(insturction_id); <span class="hljs-comment">//更新记录</span><br>  <span class="hljs-comment">//修改调出页信息</span><br>  <span class="hljs-keyword">if</span> (cur_schedule.<span class="hljs-property">page_out</span> != <span class="hljs-string">&quot;null&quot;</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">page_table</span>[cur_schedule.<span class="hljs-property">page_out</span>].<span class="hljs-property">valid</span> = <span class="hljs-literal">false</span>;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">page_table</span>[cur_schedule.<span class="hljs-property">page_out</span>].<span class="hljs-property">memory_id</span> = <span class="hljs-string">&quot;null&quot;</span>;<br>  &#125;<br>&#125; <br>...<br></code></pre></td></tr></table></figure></li><li><p>若未发生缺页，则将页表调入空闲内存块，调整LRU辅助链表，记录相关信息</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript">...<br>   <span class="hljs-keyword">else</span> &#123;<br>     <span class="hljs-comment">//页表处于内存中</span><br>     <span class="hljs-variable language_">this</span>.<span class="hljs-property">LRUlist</span>.<span class="hljs-title function_">movetoHead</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">LRUlist</span>.<span class="hljs-title function_">findIndex</span>(page.<span class="hljs-property">memory_id</span>)); <span class="hljs-comment">//将页表所在块移至链表头</span><br>     <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">instruct_record_update</span>(insturction_id); <span class="hljs-comment">//更新记录</span><br>   &#125;<br></code></pre></td></tr></table></figure></li></ol></li><li><p>执行下一条指令</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>课程项目分享</category>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
      <tag>内存管理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>电梯调度-OS课程项目</title>
    <link href="/2022/05/11/%E7%94%B5%E6%A2%AF%E8%B0%83%E5%BA%A6-OS%E8%AF%BE%E7%A8%8B%E9%A1%B9%E7%9B%AE/"/>
    <url>/2022/05/11/%E7%94%B5%E6%A2%AF%E8%B0%83%E5%BA%A6-OS%E8%AF%BE%E7%A8%8B%E9%A1%B9%E7%9B%AE/</url>
    
    <content type="html"><![CDATA[<h1 id="进程管理——电梯调度系统"><a href="#进程管理——电梯调度系统" class="headerlink" title="进程管理——电梯调度系统"></a>进程管理——电梯调度系统</h1><p>[TOC]</p><h3 id="开发环境"><a href="#开发环境" class="headerlink" title="开发环境"></a>开发环境</h3><p>开发语言：Javascript+html+css</p><p>开发框架：Vue.js 3.0+Element-plus</p><p>开发工具：Vue-cli、Vue-devtools、VScode、Edge</p><h3 id="实现方法"><a href="#实现方法" class="headerlink" title="实现方法"></a>实现方法</h3><p>引入Element-plus组件作为UI，采用Vue3框架进行组件化开发</p><p>虽然 Javascript是单线程语言，但通过调用window对象的异步方法 setTimeout 以及 setInterval，使宿主环境（此处为web browser）在JS主线程之外开启多个子线程任务队列，从而完成多线程任务</p><h3 id="项目浏览"><a href="#项目浏览" class="headerlink" title="项目浏览"></a>项目浏览</h3><ul><li>联网进入 <a href="https://pikachudy.github.io/ElevatorScheduling/">ElevatorScheduling (pikachudy.github.io)</a>在线浏览</li></ul><h3 id="界面UI说明"><a href="#界面UI说明" class="headerlink" title="界面UI说明"></a>界面UI说明</h3><h4 id="电梯内部面板UI说明："><a href="#电梯内部面板UI说明：" class="headerlink" title="电梯内部面板UI说明："></a>电梯内部面板UI说明：</h4><ul><li><p>楼层序号两侧感叹号标识并不是显示错误，而会在按下警铃按钮后变为红色以表示发出紧急信号</p></li><li><p>电梯停靠时，在电梯内部按下当前楼层按钮，电梯会开门（相当于按下了开门键）</p></li><li><p>电梯内部楼层按钮按下后即被禁用，直到电梯到达该层并停靠、开门后才恢复交互性</p></li><li><p>电梯在某层停靠时，会自动开门，开门期间电梯不会移动，期间若不按下开关门按钮，则将在五秒后关门，继续运行。右下方蓝色按钮表示电梯门当前状态，并不能点击</p></li><li><p>电梯运行时开关门按钮将被禁用，无法按下。只有电梯在某一层停靠时才可以按下开关门按钮，以此实现提早关门等操作</p></li><li><p>电梯显示屏中楼层序号变为红色时说明电梯正在此楼停靠、门处于开启状态；上下箭头变为红色则指示这当前&#x2F;前一步运行方向</p></li></ul><h4 id="外部呼叫面板UI说明"><a href="#外部呼叫面板UI说明" class="headerlink" title="外部呼叫面板UI说明"></a>外部呼叫面板UI说明</h4><ul><li>按钮按下时变为红色并禁用，直到有对应方向的电梯在该楼层停靠时（即调度任务完成）恢复</li><li>1楼的下行按钮和20楼的上行按钮只会将电梯呼叫到该层，与1楼上行、20楼下行按钮功能无区别，不会引发bug，此处留下仅为布局美观</li></ul><h3 id="组件划分"><a href="#组件划分" class="headerlink" title="组件划分"></a>组件划分</h3><h4 id="组件预览"><a href="#组件预览" class="headerlink" title="组件预览"></a>组件预览</h4><table><thead><tr><th>组件名称</th><th>负责内容</th><th>子组件</th></tr></thead><tbody><tr><td>App</td><td>接收外部按钮信息、完成外部调度逻辑,协调电梯整体调度逻辑</td><td>Elevator、Floorboard</td></tr><tr><td>Elevator</td><td>实现单部电梯系统运行功能及内部调度</td><td>null</td></tr><tr><td>FloorBoard</td><td>实现电梯外部按钮逻辑</td><td>null</td></tr></tbody></table><h4 id="各组件变量及功能"><a href="#各组件变量及功能" class="headerlink" title="各组件变量及功能"></a>各组件变量及功能</h4><h5 id="Elevator"><a href="#Elevator" class="headerlink" title="Elevator"></a>Elevator</h5><h6 id="维护变量"><a href="#维护变量" class="headerlink" title="维护变量"></a>维护变量</h6><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> &#123;<br>      <span class="hljs-attr">cur_floor</span>: <span class="hljs-number">1</span>, <span class="hljs-comment">//当前所在楼层</span><br>      <span class="hljs-attr">cur_direction</span>: <span class="hljs-number">0</span>, <span class="hljs-comment">//当前电梯趋势 1为上行、-1为下行、0为静止</span><br>      <span class="hljs-attr">cur_moving</span>: <span class="hljs-literal">false</span>, <span class="hljs-comment">//电梯默认为静止状态、主要为了控制开关门</span><br>      <span class="hljs-attr">cur_door</span>: <span class="hljs-literal">false</span>, <span class="hljs-comment">//当前门状态，true为开门</span><br>      <span class="hljs-attr">buttons_floor</span>: [], <span class="hljs-comment">//长度为20，下标+1表示楼层，内容true为被按下，在EleInit函数初始化</span><br>      <span class="hljs-attr">mission_floor</span>: [], <span class="hljs-comment">//任务序列，若内部调用无论如何都得接受</span><br>      <span class="hljs-attr">danger</span>: <span class="hljs-literal">false</span>, <span class="hljs-comment">//是否报警</span><br>      <span class="hljs-attr">mine_clock</span>: <span class="hljs-literal">null</span>, <span class="hljs-comment">//存放setInterval返回的对象便于结束</span><br>    &#125;;<br>  &#125;<br></code></pre></td></tr></table></figure><h6 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h6><p>组件内部维护了单部电梯运行所需要的信息，每个电梯都有自己的任务队列 ，单部电梯按照队列内容，依据调度算法来运行，减少各部分之间的耦合，尽可能达到高内聚</p><p><strong>mission_floor</strong> 存储电梯的任务序列，电梯依据一定的调度算法，按照队列中内容来运行。<br>在电梯内部按下按钮则对应楼层将直接加入该队列；在外部按下按钮则通过外部App组件来选择将该楼层的任务放入哪一个电梯的任务队列</p><p>在<strong>App.vue</strong>模板中挂载五次，相当于实例化五个相同但互不干扰，独立运行的对象。采用<strong>v-for</strong>循环渲染，给每一个实例化组件赋予<strong>ref</strong>属性以方便父组件区分调用</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;td v-<span class="hljs-keyword">for</span>=<span class="hljs-string">&quot;i in this.elevator_number&quot;</span> :key=<span class="hljs-string">&quot;i&quot;</span>&gt;<br>     <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">elevator</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;elevator_group&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">       @<span class="hljs-attr">upArrive</span>=<span class="hljs-string">&quot;uparriveHandler&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">       @<span class="hljs-attr">downArrive</span>=<span class="hljs-string">&quot;downarriveHandler&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">elevator</span>&gt;</span></span><br>   &lt;/td&gt;<br></code></pre></td></tr></table></figure><h5 id="FloorBoard"><a href="#FloorBoard" class="headerlink" title="FloorBoard"></a>FloorBoard</h5><h6 id="维护变量-1"><a href="#维护变量-1" class="headerlink" title="维护变量"></a>维护变量</h6><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> &#123;<br>      <span class="hljs-attr">buttons_upordown</span>: [], <span class="hljs-comment">// 下标为楼层减1</span><br>    &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="简要介绍"><a href="#简要介绍" class="headerlink" title="简要介绍"></a>简要介绍</h6><p><strong>buttons_upordown</strong> 存储楼层按钮对象，对应对象中两按钮按下状态</p><p>在按钮可用时按下按钮，会发送事件并传递楼层、方向信息。该事件会触发父组件 <strong>App</strong> 中的调度方法来将该任务加入至合适的电梯的任务序列中（外部调度）</p><h5 id="App"><a href="#App" class="headerlink" title="App"></a>App</h5><h6 id="维护变量-2"><a href="#维护变量-2" class="headerlink" title="维护变量"></a>维护变量</h6><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> &#123;<br>      <span class="hljs-attr">elevator_number</span>: <span class="hljs-number">5</span>, <span class="hljs-comment">//电梯数目（初始化为5）</span><br>      <span class="hljs-attr">waiting_queue</span>:[]<span class="hljs-comment">//等待队列，二维数组[0为上行，1为下行][floor-1]，内部存有相应上、下行楼层等待队列计时器返回的对象</span><br>    &#125;;<br>  &#125;,<br></code></pre></td></tr></table></figure><h6 id="简要介绍-1"><a href="#简要介绍-1" class="headerlink" title="简要介绍"></a>简要介绍</h6><p>外部调度任务有时需要等待，此时需要计时器来帮助决定何时放入合适的电梯任务序列中，需要使用 <strong>waiting_queue</strong> 存储相应任务的计时器对象</p><h3 id="算法设计及实现"><a href="#算法设计及实现" class="headerlink" title="算法设计及实现"></a>算法设计及实现</h3><h4 id="电梯内部调度算法设计"><a href="#电梯内部调度算法设计" class="headerlink" title="电梯内部调度算法设计"></a>电梯内部调度算法设计</h4><p>电梯的初始方向与第一个加入任务队列的楼层与电梯当前所在楼层的关系有关，此后的调度算法默认保持原来运行方向，直到对应方向上无楼层在目标队列中时再静止或改变方向。</p><p>以电梯上行状态举例，电梯没经过一个楼层将会判断该楼层是否处于任务队列中，若在则将在任务队列中将当前楼层删去，进行停靠、开门动作，并在关门后（不能立马检测是因为在停靠期间乘客还会在电梯内部按下自己想去的楼层导致任务序列更新）对任务序列进行检测以决定下一步行驶方向：</p><ol><li>若任务队列中目标楼层最大值大于当前楼层，则继续保持上行状态</li><li>若任务队列中目标楼层最大值小于于当前楼层，则转换为下行状态</li><li>若任务队列为空，则电梯静止，等待新任务加入任务队列</li></ol><h4 id="电梯内部调度算法实现"><a href="#电梯内部调度算法实现" class="headerlink" title="电梯内部调度算法实现"></a>电梯内部调度算法实现</h4><p>采用异步方法 <strong>setInterval</strong> （在钩子函数中设置及卸载）每隔两秒执行相应回调函数<strong>UpdateStatus</strong>，若此时电梯门为开启状态或任务序列为空则直接跳出，否则根据当前电梯方向更新一次电梯楼层，并检测当前楼层是否在任务序列中</p><p>若在则调用方法 <strong>DoorOpen</strong> 将门打开（在 <strong>DoorOpen</strong> 函数中进行判断避免重复开门，主要是为了避免接下来定时器的重复设定），若正常则调用异步方法 <strong>setTimeout</strong> 使5秒后执行 <strong>DoorClose</strong> （在其中添加判断避免重复执行），若正常则关门，并调用方法 <strong>DirectionNext</strong> 确定下一步行进方向，以此来模拟电梯行进及方向选取</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-attr">methods</span>: &#123;<br>   <span class="hljs-comment">//选择方向</span><br>   <span class="hljs-title class_">DirectionNext</span>() &#123;<br>     <span class="hljs-keyword">if</span> (!<span class="hljs-variable language_">this</span>.<span class="hljs-property">mission_floor</span>.<span class="hljs-property">length</span>) &#123;<br>       <span class="hljs-variable language_">this</span>.<span class="hljs-property">cur_moving</span> = <span class="hljs-literal">false</span>;<br>       <span class="hljs-variable language_">this</span>.<span class="hljs-property">cur_direction</span> = <span class="hljs-number">0</span>;<br>       <span class="hljs-keyword">return</span>;<br>     &#125;<br>     <span class="hljs-keyword">var</span> max = <span class="hljs-title class_">Math</span>.<span class="hljs-property">max</span>.<span class="hljs-title function_">apply</span>(<span class="hljs-title class_">Math</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">mission_floor</span>);<br>     <span class="hljs-keyword">var</span> min = <span class="hljs-title class_">Math</span>.<span class="hljs-property">min</span>.<span class="hljs-title function_">apply</span>(<span class="hljs-title class_">Math</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">mission_floor</span>);<br>     <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">cur_direction</span> == <span class="hljs-number">1</span>) &#123;<br>       <span class="hljs-comment">//电梯上行则看最大值，若做差大于0则继续上行——做差不可能等于0</span><br>       <span class="hljs-keyword">if</span> (max - <span class="hljs-variable language_">this</span>.<span class="hljs-property">cur_floor</span> &gt; <span class="hljs-number">0</span>) &#123;<br>         <span class="hljs-keyword">return</span>;<br>       &#125; <span class="hljs-keyword">else</span> &#123;<br>         <span class="hljs-variable language_">this</span>.<span class="hljs-property">cur_direction</span> = -<span class="hljs-number">1</span>;<br>       &#125;<br>     &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">cur_direction</span> == -<span class="hljs-number">1</span>) &#123;<br>       <span class="hljs-keyword">if</span> (min - <span class="hljs-variable language_">this</span>.<span class="hljs-property">cur_floor</span> &lt; <span class="hljs-number">0</span>) &#123;<br>         <span class="hljs-keyword">return</span>;<br>       &#125; <span class="hljs-keyword">else</span> &#123;<br>         <span class="hljs-variable language_">this</span>.<span class="hljs-property">cur_direction</span> = <span class="hljs-number">1</span>;<br>       &#125;<br>     &#125;<br>   &#125;,<br><br>   <span class="hljs-comment">//开门</span><br>   <span class="hljs-title class_">DoorOpen</span>(time) &#123;<br>     <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">cur_moving</span>) &#123;<br>       <span class="hljs-keyword">return</span>;<br>     &#125;<br>     <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">cur_door</span>) &#123;<br>       <span class="hljs-keyword">return</span>; <span class="hljs-comment">//防止重复设定定时器</span><br>     &#125;<br>     <span class="hljs-variable language_">this</span>.<span class="hljs-property">cur_door</span> = <span class="hljs-literal">true</span>;<br>     <span class="hljs-comment">//两秒后关门</span><br>     <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>       <span class="hljs-variable language_">this</span>.<span class="hljs-title class_">DoorClose</span>();<br>     &#125;, time);<br>   &#125;,<br><br>   <span class="hljs-comment">//关门</span><br>   <span class="hljs-title class_">DoorClose</span>() &#123;<br>     <span class="hljs-variable language_">this</span>.<span class="hljs-title class_">DirectionNext</span>();<span class="hljs-comment">//选取下一个方向</span><br>     <br>     <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">cur_moving</span>) &#123;<br>       <span class="hljs-keyword">return</span>;<br>     &#125;<br>     <span class="hljs-keyword">if</span> (!<span class="hljs-variable language_">this</span>.<span class="hljs-property">cur_door</span>) &#123;<br>       <span class="hljs-keyword">return</span>; <span class="hljs-comment">//防止重复</span><br>     &#125;<br>     <span class="hljs-variable language_">this</span>.<span class="hljs-property">cur_door</span> = <span class="hljs-literal">false</span>;<br>     <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">mission_floor</span>.<span class="hljs-property">length</span> == <span class="hljs-number">0</span>) &#123;<br>       <span class="hljs-variable language_">this</span>.<span class="hljs-property">cur_moving</span> = <span class="hljs-literal">false</span>;<br>     &#125; <span class="hljs-keyword">else</span> &#123;<br>       <span class="hljs-variable language_">this</span>.<span class="hljs-property">cur_moving</span> = <span class="hljs-literal">true</span>;<br>     &#125;<br>   &#125;,<br><br>   <span class="hljs-comment">//当电梯内有人按下楼层时调用</span><br>   <span class="hljs-title class_">FloorClick</span>(i) &#123;<br>     <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(i + <span class="hljs-string">&quot;被按下！&quot;</span>);<br>     <span class="hljs-comment">//在当前楼层停止时按下当前楼层按钮会开门</span><br>     <span class="hljs-keyword">if</span> (i == <span class="hljs-variable language_">this</span>.<span class="hljs-property">cur_floor</span> &amp;&amp; <span class="hljs-variable language_">this</span>.<span class="hljs-property">cur_moving</span> == <span class="hljs-literal">false</span>) &#123;<br>       <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;已在当前楼层停止&quot;</span>);<br>       <span class="hljs-variable language_">this</span>.<span class="hljs-title class_">DoorOpen</span>(<span class="hljs-number">5000</span>); <span class="hljs-comment">//5秒后关门</span><br>       <span class="hljs-keyword">return</span>;<br>     &#125;<br>     <span class="hljs-comment">//判断是否在任务队列中</span><br>     <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">mission_floor</span>.<span class="hljs-title function_">indexOf</span>(i) != -<span class="hljs-number">1</span>) &#123;<br>       <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;当前楼层已经在任务队列中了！&quot;</span>);<br>       <span class="hljs-keyword">return</span>;<br>     &#125;<br>     <span class="hljs-variable language_">this</span>.<span class="hljs-property">mission_floor</span>.<span class="hljs-title function_">push</span>(i);<br>     <span class="hljs-variable language_">this</span>.<span class="hljs-property">buttons_floor</span>[i - <span class="hljs-number">1</span>] = <span class="hljs-literal">true</span>; <span class="hljs-comment">//表示为按钮已按下</span><br>   &#125;,<br>       <br>   <span class="hljs-comment">//间隔1.5秒执行一次，以此来模拟电梯上下行</span><br>   <span class="hljs-title class_">UpdateStatus</span>() &#123;<br>     <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;更新电梯状态&quot;</span>);<br>     <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">cur_door</span>) &#123;<br>       <span class="hljs-comment">//若门在开启状态</span><br>       <span class="hljs-keyword">return</span>;<br>     &#125;<br>     <span class="hljs-comment">//若任务队列为空，则置为静止状态</span><br>     <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">mission_floor</span>.<span class="hljs-property">length</span> == <span class="hljs-number">0</span>) &#123;<br>       <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">cur_direction</span> != <span class="hljs-number">0</span>) &#123;<br>         <span class="hljs-variable language_">this</span>.<span class="hljs-property">cur_direction</span> = <span class="hljs-number">0</span>;<br>       &#125;<br>       <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">cur_moving</span> != <span class="hljs-literal">false</span>) &#123;<br>         <span class="hljs-variable language_">this</span>.<span class="hljs-property">cur_moving</span> = <span class="hljs-literal">false</span>;<br>       &#125;<br>       <span class="hljs-keyword">return</span>;<br>     &#125; <span class="hljs-keyword">else</span> &#123;<br>       <span class="hljs-variable language_">this</span>.<span class="hljs-property">cur_moving</span> = <span class="hljs-literal">true</span>;<br>     &#125;<br>     <span class="hljs-variable language_">this</span>.<span class="hljs-property">cur_floor</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">cur_floor</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">cur_direction</span>;<br>     <span class="hljs-comment">//若任务队列不空</span><br>     <span class="hljs-comment">//判断当前楼层是否在队列中——即是否到达目的地</span><br>     <span class="hljs-keyword">var</span> <span class="hljs-title class_">ArriveCheck</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">mission_floor</span>.<span class="hljs-title function_">indexOf</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">cur_floor</span>);<br>     <span class="hljs-comment">//若不在队列中——未到达目的地</span><br>     <span class="hljs-keyword">if</span> (<span class="hljs-title class_">ArriveCheck</span> == -<span class="hljs-number">1</span>) &#123;<br>       <span class="hljs-comment">//若当前为静止状态</span><br>       <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">cur_direction</span> == <span class="hljs-number">0</span>) &#123;<br>         <span class="hljs-keyword">let</span> <span class="hljs-title class_">UorD</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">mission_floor</span>[<span class="hljs-number">0</span>] - <span class="hljs-variable language_">this</span>.<span class="hljs-property">cur_floor</span>; <span class="hljs-comment">//取第一个任务与当前楼层做差,不可能为0</span><br>         <span class="hljs-keyword">if</span> (<span class="hljs-title class_">UorD</span> &gt; <span class="hljs-number">0</span>) &#123;<br>           <span class="hljs-variable language_">this</span>.<span class="hljs-property">cur_direction</span> = <span class="hljs-number">1</span>;<br>         &#125; <span class="hljs-keyword">else</span> &#123;<br>           <span class="hljs-variable language_">this</span>.<span class="hljs-property">cur_direction</span> = -<span class="hljs-number">1</span>;<br>         &#125;<br>       &#125;<br>     &#125;<br>     <span class="hljs-comment">//若当前不为静止状态——说明此时方向一定正确且未到达</span><br>     <span class="hljs-comment">//若在队列中——已经到达目的地</span><br>     <span class="hljs-keyword">else</span> &#123;<br>       <span class="hljs-variable language_">this</span>.<span class="hljs-property">mission_floor</span>.<span class="hljs-title function_">splice</span>(<span class="hljs-title class_">ArriveCheck</span>, <span class="hljs-number">1</span>); <span class="hljs-comment">//在此将楼层从任务队列中取出来</span><br>       <span class="hljs-variable language_">this</span>.<span class="hljs-property">buttons_floor</span>[<span class="hljs-variable language_">this</span>.<span class="hljs-property">cur_floor</span> - <span class="hljs-number">1</span>] = <span class="hljs-literal">false</span>;<br>       <span class="hljs-variable language_">this</span>.<span class="hljs-property">cur_moving</span> = <span class="hljs-literal">false</span>; <span class="hljs-comment">//先停下来才能开门</span><br>       <br>       <span class="hljs-keyword">if</span> (!<span class="hljs-variable language_">this</span>.<span class="hljs-property">mission_floor</span>.<span class="hljs-property">length</span>) &#123;<br>         <span class="hljs-comment">//若任务队列已空则静止</span><br>         <span class="hljs-variable language_">this</span>.<span class="hljs-property">cur_moving</span> = <span class="hljs-literal">false</span>;<br>         <span class="hljs-variable language_">this</span>.<span class="hljs-property">cur_direction</span> = <span class="hljs-number">0</span>;<br>       &#125;<br><br>       <span class="hljs-keyword">if</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">cur_direction</span>==<span class="hljs-number">0</span>)&#123;<br>         <span class="hljs-variable language_">this</span>.$emit(<span class="hljs-string">&quot;upArrive&quot;</span>,<span class="hljs-variable language_">this</span>.<span class="hljs-property">cur_floor</span>);<br>         <span class="hljs-variable language_">this</span>.$emit(<span class="hljs-string">&quot;downArrive&quot;</span>,<span class="hljs-variable language_">this</span>.<span class="hljs-property">cur_floor</span>);<br>       &#125;<br>       <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">cur_direction</span>==<span class="hljs-number">1</span>)&#123;<br>         <span class="hljs-comment">//之前方向为向上</span><br>         <span class="hljs-variable language_">this</span>.$emit(<span class="hljs-string">&quot;upArrive&quot;</span>,<span class="hljs-variable language_">this</span>.<span class="hljs-property">cur_floor</span>)<br>       &#125;<br>       <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">cur_direction</span>==-<span class="hljs-number">1</span>)&#123;<br>         <span class="hljs-comment">//之前方向为向下</span><br>         <span class="hljs-variable language_">this</span>.$emit(<span class="hljs-string">&quot;downArrive&quot;</span>,<span class="hljs-variable language_">this</span>.<span class="hljs-property">cur_floor</span>)<br>       &#125;<br><br>       <span class="hljs-variable language_">this</span>.<span class="hljs-title class_">DoorOpen</span>(<span class="hljs-number">5000</span>);<br>       <span class="hljs-comment">//开门5s后关门，选择下一个任务</span><br>     &#125;<br>   &#125;,<br><br></code></pre></td></tr></table></figure><h4 id="电梯外部调度算法设计"><a href="#电梯外部调度算法设计" class="headerlink" title="电梯外部调度算法设计"></a>电梯外部调度算法设计</h4><p>外部调度任务主要是将外部呼叫请求根据楼层、方向及之后一段时间内各个电梯状态，将请求放入合适的电梯的任务序列中，使等待时间尽可能缩小</p><p>当有新的外部呼叫时，检测所有电梯状态并按以下顺序依次进行判断：</p><ol><li><p>若有电梯在此层停靠且下一步行进方向与呼叫方向相同（或静止），则执行开门操作，任务完成；若有电梯在此层但下一步行进方向与呼叫方向相反则先略过</p></li><li><p>若无电梯在此层，则检测是否有在当前方向下会经过该层或静止的电梯，若有则将其加入候选队列</p><blockquote><p>假如在8层有上行呼叫请求，则将当前低于8层的处于上行状态的电梯或者处于静止状态的加入候选队列</p></blockquote></li><li><p>若候选队列仍为空，则使该呼叫请求等待。并调用异步方法<strong>setInterval</strong>。每隔0.5s检测一次电梯群状态（即进行一次1-2判断）。若有电梯满足要求则加入候选队列，并调用<strong>clearInterval</strong>停止计时器检测</p></li></ol><p>在候选队列中选择与呼叫楼层距离最小的电梯，将呼叫楼层加入其任务队列</p><p>采用此方法可以保证选择的电梯到达呼叫层时下一步方向与呼叫方向相同或下一步方向为静止。且在无符合要求的情况下将请求挂起等待，直至满足要求的电梯出现再从中择优，而不是盲目的加入某个电梯的任务队列，提高了效率</p><p>且由于电梯自身在当前方向上无任务时，会改变方向或转为静止态（电梯内部调度算法决定的），因此并不会存在所有电梯一直都不满足、候选队列一直为空的情况，也就是说并不会出现某一外部呼叫请求无限等待的情况</p><h4 id="电梯外部调度算法实现"><a href="#电梯外部调度算法实现" class="headerlink" title="电梯外部调度算法实现"></a>电梯外部调度算法实现</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-attr">methods</span>: &#123;<br>    <br>    <span class="hljs-comment">/*只展示部分方法*/</span><br>    <br>    <span class="hljs-title function_">minDistenceEle</span>(<span class="hljs-params">candidateEles, floor_calling, elevators</span>) &#123;<br>      <span class="hljs-comment">//计算最小距离的电梯</span><br>      <span class="hljs-keyword">var</span> minDistence = <span class="hljs-number">100</span>; <span class="hljs-comment">//一个不可能的极大数</span><br>      <span class="hljs-keyword">var</span> minElevator = <span class="hljs-number">0</span>;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; candidateEles.<span class="hljs-property">length</span>; i++) &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">abs</span>(elevators[i].<span class="hljs-property">cur_floor</span> - floor_calling) &lt; minDistence) &#123;<br>          minDistence = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">abs</span>(elevators[i].<span class="hljs-property">cur_floor</span> - floor_calling);<br>          minElevator = i;<br>        &#125;<br>      &#125;<br>      <span class="hljs-keyword">return</span> candidateEles[minElevator];<br>    &#125;,<br><br>    <span class="hljs-title function_">upHandler</span>(<span class="hljs-params">arg</span>) &#123;<br>      <span class="hljs-keyword">let</span> elevators = <span class="hljs-variable language_">this</span>.<span class="hljs-property">$refs</span>.<span class="hljs-property">elevator_group</span>;<br>      <span class="hljs-keyword">let</span> &#123; direction_calling, floor_calling &#125; = arg;<br>      <span class="hljs-keyword">var</span> candidateEles = [];<br>      <span class="hljs-comment">//处理外部调度信息</span><br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>        <span class="hljs-keyword">if</span> (elevators[i].<span class="hljs-property">cur_direction</span> == <span class="hljs-number">0</span>) &#123;<br>          <span class="hljs-comment">//若有静止电梯</span><br>          <span class="hljs-keyword">if</span> (elevators[i].<span class="hljs-property">cur_floor</span> == floor_calling) &#123;<br>            <span class="hljs-comment">//若电梯就静止在此层则开门就直接ok</span><br>            <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">uparriveHandler</span>(floor_calling);<br>            elevators[i].<span class="hljs-title class_">DoorOpen</span>(<span class="hljs-number">2000</span>);<br>            <span class="hljs-keyword">return</span>;<br>          &#125;<br>          <span class="hljs-comment">//若静止但不在此层则加入候选队列</span><br>          candidateEles.<span class="hljs-title function_">push</span>(i);<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (<br>          elevators[i].<span class="hljs-property">cur_direction</span> == direction_calling &amp;&amp;<br>          floor_calling - elevators[i].<span class="hljs-property">cur_floor</span> &gt; <span class="hljs-number">0</span><br>        ) &#123;<br>          <span class="hljs-comment">//若电梯同向且尚未经过此层则加入候选队列</span><br>          candidateEles.<span class="hljs-title function_">push</span>(i);<br>        &#125;<br>      &#125;<br><br>      <span class="hljs-keyword">if</span> (candidateEles.<span class="hljs-property">length</span> != <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">//若已有则挑选然后加入任务队列</span><br>        <span class="hljs-keyword">let</span> elevator_index = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">minDistenceEle</span>(<br>          candidateEles,<br>          floor_calling,<br>          elevators<br>        );<br>        <span class="hljs-keyword">if</span> (<br>          <span class="hljs-variable language_">this</span>.<span class="hljs-property">$refs</span>.<span class="hljs-property">elevator_group</span>[elevator_index].<span class="hljs-property">mission_floor</span>.<span class="hljs-title function_">indexOf</span>(<br>            floor_calling<br>          ) == -<span class="hljs-number">1</span><br>        ) &#123;<br>          <span class="hljs-variable language_">this</span>.<span class="hljs-property">$refs</span>.<span class="hljs-property">elevator_group</span>[elevator_index].<span class="hljs-property">mission_floor</span>.<span class="hljs-title function_">push</span>(<br>            floor_calling<br>          );<br>        &#125;<br>        <span class="hljs-keyword">return</span>;<br>      &#125;<br>      <span class="hljs-comment">//处理无候选结果,此时情况为电梯反向或虽然同向但已经经过了该层</span><br>      <span class="hljs-comment">//此时丢入等待序列，每0.5秒检测一次电梯状态，直至出现静止电梯或同向未经过该层电梯再结束子线程</span><br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(floor_calling+<span class="hljs-string">&quot;层的&quot;</span>+direction_calling+<span class="hljs-string">&quot;请求放入等待队列&quot;</span>);<br>      <span class="hljs-keyword">var</span> id=<span class="hljs-built_in">setInterval</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">upWaiting</span>,<span class="hljs-number">100</span>,&#123;direction_calling,floor_calling,id&#125;);<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">waiting_queue</span>[<span class="hljs-number">0</span>][floor_calling-<span class="hljs-number">1</span>]=id;<br>    &#125;,<br><br>    <span class="hljs-title function_">upWaiting</span>(<span class="hljs-params">arg</span>) &#123;<br>      <span class="hljs-keyword">let</span> &#123; direction_calling, floor_calling &#125; = arg;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;检测&quot;</span>+floor_calling+<span class="hljs-string">&quot;层的&quot;</span>+direction_calling+<span class="hljs-string">&quot;请求&quot;</span>);<br>      <span class="hljs-keyword">let</span> elevators = <span class="hljs-variable language_">this</span>.<span class="hljs-property">$refs</span>.<span class="hljs-property">elevator_group</span>;<br>      <span class="hljs-keyword">var</span> candidateEles = [];<br>      <span class="hljs-keyword">var</span> id =  <span class="hljs-variable language_">this</span>.<span class="hljs-property">waiting_queue</span>[<span class="hljs-number">0</span>][floor_calling-<span class="hljs-number">1</span>];<br>      <span class="hljs-comment">//处理外部调度信息</span><br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>        <span class="hljs-keyword">if</span> (elevators[i].<span class="hljs-property">cur_direction</span> == <span class="hljs-number">0</span>) &#123;<br>          <span class="hljs-comment">//若有静止电梯</span><br>          <span class="hljs-keyword">if</span> (elevators[i].<span class="hljs-property">cur_floor</span> == floor_calling) &#123;<br>            <span class="hljs-comment">//若电梯就静止在此层则开门就直接ok</span><br>            elevators[i].<span class="hljs-title class_">DoorOpen</span>(<span class="hljs-number">2000</span>);<br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(floor_calling+<span class="hljs-string">&quot;层的&quot;</span>+direction_calling+<span class="hljs-string">&quot;请求已满足，在&quot;</span>+ i+<span class="hljs-string">&quot;号电梯&quot;</span>);<br>            <span class="hljs-built_in">clearInterval</span>(id);    <span class="hljs-comment">//停用计时器</span><br>            <span class="hljs-keyword">return</span>;<br>          &#125;<br>          <span class="hljs-comment">//若静止但不在此层则加入候选队列</span><br>          candidateEles.<span class="hljs-title function_">push</span>(i);<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (<br>          elevators[i].<span class="hljs-property">cur_direction</span> == direction_calling &amp;&amp;<br>          floor_calling - elevators[i].<span class="hljs-property">cur_floor</span> &gt; <span class="hljs-number">0</span><br>        ) &#123;<br>          <span class="hljs-comment">//若电梯同向且尚未经过此层则加入候选队列</span><br>          candidateEles.<span class="hljs-title function_">push</span>(i);<br>        &#125;<br>      &#125;<br><br>      <span class="hljs-keyword">if</span> (candidateEles.<span class="hljs-property">length</span> != <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">//若已有则挑选然后加入任务队列</span><br>        <span class="hljs-keyword">let</span> elevator_index = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">minDistenceEle</span>(<br>          candidateEles,<br>          floor_calling,<br>          elevators<br>        );<br>        <span class="hljs-keyword">if</span> (<br>          <span class="hljs-variable language_">this</span>.<span class="hljs-property">$refs</span>.<span class="hljs-property">elevator_group</span>[elevator_index].<span class="hljs-property">mission_floor</span>.<span class="hljs-title function_">indexOf</span>(<br>            floor_calling<br>          ) == -<span class="hljs-number">1</span><br>        ) &#123;<br>          <span class="hljs-variable language_">this</span>.<span class="hljs-property">$refs</span>.<span class="hljs-property">elevator_group</span>[elevator_index].<span class="hljs-property">mission_floor</span>.<span class="hljs-title function_">push</span>(<br>            floor_calling<br>          );<br>        &#125;<br>        <span class="hljs-built_in">clearInterval</span>(id);<span class="hljs-comment">//停用计时器</span><br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(floor_calling+<span class="hljs-string">&quot;层的&quot;</span>+direction_calling+<span class="hljs-string">&quot;请求已放入&quot;</span>+ elevator_index+<span class="hljs-string">&quot;号电梯任务队列&quot;</span>);<br>        <span class="hljs-keyword">return</span>;<br>      &#125;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(floor_calling+<span class="hljs-string">&quot;层的&quot;</span>+direction_calling+<span class="hljs-string">&quot;请求暂未满足 继续等待&quot;</span>);<br>      <span class="hljs-keyword">return</span>;<br>    &#125;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><p>在外部面板按钮被按下后，<strong>FloorBoard</strong> 会发出相应事件，被父组件<strong>App</strong>捕获到后调用方法 <strong>upHandler</strong> 实行调度算法，在需要时采用异步方法<strong>setInterval</strong>，每隔0.1s调用一次<strong>upWaiting</strong>方法进行检测，直至某次检测候选队列不为空再调用<strong>clearInterval</strong>清除定时器，完成择优，并将呼叫请求楼层放入相应电梯任务序列</p><h3 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h3><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ol><li><p>电梯在当前方向<strong>无任务后便会改变方向或停止</strong>，而不会到达顶层或底层再改变状态，提高效率</p></li><li><p>在有外部呼叫请求时，<strong>优先将与呼叫方向同向且未经过呼叫楼层的电梯及静止状态的电梯加入候选队列</strong>，再根据距离择优选取，在保证所分配的电梯到达呼叫楼层时，下一步行进方向与呼叫方向同向或静止的前提下能尽快到达</p></li><li><p>在当前所有电梯都不能满足与呼叫方向同向且未经过呼叫楼层的电梯或为静止状态时<strong>先使呼叫请求等待</strong>，<strong>待出现满足条件的电梯时再加入候选队列</strong>，择优选取。且由于优点一，呼叫请求等待的时间往往不会很长</p></li></ol><h4 id="不足之处"><a href="#不足之处" class="headerlink" title="不足之处"></a>不足之处</h4><ol><li><p>外部请求等待时，一旦碰到方向符合要求的电梯便将其加入候选队列。有些情况下这样的任务分配依旧过早，考虑下面的情况：</p><blockquote><p>假设有两部电梯，第一部目前在15楼，要上行至17楼，随后队列为空；第二部目前在5楼，要上行至8楼，随后队列为空。不考虑电梯停靠时间，每过3s电梯行进一层，现在在3楼外部发出上行呼叫。</p><p>按照本项目外部调度算法，一开始两部电梯都不满足，请求等待；</p><p>6s后，第一部电梯上行至17楼后静止，此时第二部在7楼继续上行，依据算法则将3楼上行请求加入第一部电梯任务队列，其再经过42s到达第三层，共用时48s；</p><p>若分配给第二部电梯，则只需24s</p></blockquote><p>但实际条件下由于乘客会随时在电梯内选择新楼层，这种情况并不会经常出现</p><blockquote><p>例如若在第二部电梯在5-8楼上行期间，电梯内部乘客按下了17楼按钮，那么第二部电梯应当在8楼停靠后继续上行至17层，此时显然没有第一部电梯快</p></blockquote><p>考虑到这种情况，最终仍采取了当前的外部调度的算法，至少在保证了正确呼叫的前提下尽可能的根据电梯的最新状态进行调度</p></li><li><p>此处的电梯仍为理想化模型，在调度时未考虑电梯载重量与当前乘客重量；同时也未考虑到电梯停靠时间所带来的影响，下一步完善的话会考虑根据电梯现有的任务队列计算停靠次数，与电梯至目标楼层的距离分别加权求和，择优调度</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>课程项目分享</category>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
      <tag>进程调度</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ES6用法总结</title>
    <link href="/2022/03/24/ES6%E7%94%A8%E6%B3%95%E6%80%BB%E7%BB%93/"/>
    <url>/2022/03/24/ES6%E7%94%A8%E6%B3%95%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h2 id="ES6学习总结记录"><a href="#ES6学习总结记录" class="headerlink" title="ES6学习总结记录"></a>ES6学习总结记录</h2><p>[TOC]</p><p>前段时间自学前端时遇到了ES6新增部分，学习过后感觉对于构建大型项目还是挺有帮助的，特在此记录分享</p><hr><h4 id="let-amp-const"><a href="#let-amp-const" class="headerlink" title="let&amp;const"></a>let&amp;const</h4><p>const 与C++中的const关键字差别不大；</p><p>与 var 相比，let将变量作用域<strong>限定到了代码块中</strong></p><p>此外，还需要注意的一点是，在全局使用 var 变量，会将其添加到上下文对象window中，而let不会</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; ++i )<br>    ;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(i); <span class="hljs-comment">//输出10</span><br><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; ++i )<br>    ;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(i); <span class="hljs-comment">//输出 undefined</span><br><br><span class="hljs-keyword">var</span> aloha = <span class="hljs-string">&quot;pika!&quot;</span>;<br><span class="hljs-keyword">let</span> deemo = <span class="hljs-string">&quot;pika pi!&quot;</span>;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( <span class="hljs-variable language_">window</span>.<span class="hljs-property">aloha</span> );<span class="hljs-comment">//输出 pika!</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( <span class="hljs-variable language_">window</span>.<span class="hljs-property">deemo</span> );<span class="hljs-comment">//报错</span><br></code></pre></td></tr></table></figure><h4 id="模板字面量"><a href="#模板字面量" class="headerlink" title="模板字面量"></a>模板字面量</h4><ul><li><p>多行字符串 <strong>`demo`</strong> : 反引号中所有空白字符（空格、换行、制表符等）都属于字符串的一部分</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> message = <span class="hljs-string">`Hello</span><br><span class="hljs-string">World!`</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(message);<br><span class="hljs-comment">//Hello</span><br><span class="hljs-comment">//World!</span><br></code></pre></td></tr></table></figure></li><li><p>占位符 ${ … } : 将表达式的值作为字符串的一部分输出</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> amount = <span class="hljs-number">5</span>;<br><span class="hljs-keyword">let</span> price = <span class="hljs-number">3.6</span>;<br><span class="hljs-keyword">let</span> message = <span class="hljs-string">`The total price is <span class="hljs-subst">$&#123;price * amount&#125;</span>!`</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(message);<span class="hljs-comment">//The total price is 18!</span><br></code></pre></td></tr></table></figure></li></ul><h4 id="函数形参默认参数："><a href="#函数形参默认参数：" class="headerlink" title="函数形参默认参数："></a>函数形参默认参数：</h4><p>可在指定默认参数后继续声明无默认值的参数，但此时需要传入undefine使用默认值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">demo</span>(<span class="hljs-params">url = <span class="hljs-string">&quot;/home&quot;</span>, timeout = <span class="hljs-number">2000</span>, callback </span>);<br><span class="hljs-title function_">demo</span>(<span class="hljs-literal">undefined</span>, <span class="hljs-literal">undefined</span> ,<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;&#125;);<span class="hljs-comment">//使用默认参数</span><br></code></pre></td></tr></table></figure><h4 id="rest参数"><a href="#rest参数" class="headerlink" title="rest参数"></a>rest参数</h4><p>JS的一个特点是，无论在函数定义里声明了多少形参，都可以传入<strong>任意数量</strong>的参数</p><ul><li><p>arguments 对象（旧版）：</p><p>无需在定义中显式声明，可直接在函数中调用，其包含<strong>所有传入</strong>的参数，可使用下标直接遍历</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">demo</span>(<span class="hljs-params">pika</span>)&#123;<br>    <span class="hljs-comment">//若pika为true则遍历输出所有后续形参</span><br>    <span class="hljs-keyword">if</span>(pika)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt; <span class="hljs-variable language_">arguments</span>.<span class="hljs-title function_">length</span>(); ++i)<span class="hljs-comment">//从 1 开始是因为arguments[0]为形参pika</span><br>        &#123;<br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">arguments</span>[i]);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-title function_">demo</span>(<span class="hljs-literal">true</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>);<span class="hljs-comment">//23456</span><br></code></pre></td></tr></table></figure><p>缺陷：</p><ol><li>无法从函数形参列表看出函数是否被设计为接受任意数量的参数</li><li>使用多传入的形参时需要考虑下标起点</li></ol></li><li><p>rest参数（ES6新增）</p><p>​rest是一个数组，包含<strong>自它之后</strong>传入的所有参数，可直接下标遍历</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">demo</span>(<span class="hljs-params">pika, ...data</span>)&#123;<br>    <span class="hljs-comment">//若pika为true则遍历输出所有后续形参</span><br>    <span class="hljs-keyword">if</span>(pika)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; data.<span class="hljs-title function_">length</span>(); ++i)<span class="hljs-comment">//从 0 开始是因为rest参数名只包含自它之后传入的所有参数</span><br>        &#123;<br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data[i]);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-title function_">demo</span>(<span class="hljs-literal">true</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>);<span class="hljs-comment">//23456</span><br></code></pre></td></tr></table></figure><ol><li><p>要想使用rest，需要在形参名前加三个点，表明这是一个rest参数，用于获取函数多传进来的形参——解决缺陷1</p></li><li><p>无需考虑多传入的形参的下标起点问题，rest参数名只包含自它之后传入的所有参数</p></li><li><p>每个函数最多只能声明一个rest参数，且必须为最后一个参数</p></li></ol></li></ul><h4 id="展开运算符"><a href="#展开运算符" class="headerlink" title="展开运算符"></a>展开运算符</h4><p>展开运算符为  <strong>…</strong>  ，可以将一个数组转换为各个独立的参数，也可去除对象的所有可遍历属性，需要注意与rest参数区分</p><p>示例：</p><ul><li><p>提取数组中值并作为形参 </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">sum</span> (a,b,c)&#123;<br>    <span class="hljs-keyword">return</span> a+b+c;<br>&#125;<br><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>];<br><span class="hljs-title function_">sum</span>(...arr);<span class="hljs-comment">//等价于 sum(arr[0],arr[1],arr[2]);</span><br></code></pre></td></tr></table></figure></li><li><p>数组复制，合并</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//将arr1数组赋值给arr2</span><br>arr1=[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>];<br>arr2=[...arr1];<span class="hljs-comment">//[1,2,3]</span><br><span class="hljs-comment">//将arr1与arr2合并为arr3</span><br>arr3=[...arr1, ...arr2];<span class="hljs-comment">//[1,2,3,1,2,3]</span><br></code></pre></td></tr></table></figure></li><li><p>对象同理</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> object1=&#123;<br>    <span class="hljs-attr">name</span>:<span class="hljs-string">&quot;pika&quot;</span>,<br>    <span class="hljs-attr">age</span>:<span class="hljs-string">&quot;18&quot;</span><br>&#125;<br><span class="hljs-keyword">let</span> object2=&#123;<br>    ...object1,<br>    <span class="hljs-attr">slogan</span>:<span class="hljs-string">&quot;wow&quot;</span><br>&#125;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(object2);<span class="hljs-comment">//&#123;name:&#x27;pika&#x27;,age:&#x27;18&#x27;,slogan:&#x27;wow&#x27;&#125; </span><br></code></pre></td></tr></table></figure></li></ul><h4 id="对象字面量语法扩展"><a href="#对象字面量语法扩展" class="headerlink" title="对象字面量语法扩展"></a>对象字面量语法扩展</h4><p>对面自变量是JS中创建对象的一种常用方法，ES6中增加了以下几种语法</p><ol><li><p>属性初始值的简写</p><p>在对象的一个属性和给其赋值的本地变量名称相同时，可不用写键值对，只写属性名即可</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//函数demo返回一个object</span><br><span class="hljs-comment">//常用方法</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">demo</span>(<span class="hljs-params">color, doors</span>)&#123;<br>    <span class="hljs-keyword">var</span> mineObject=&#123;<br>        color = color,<br>        doors = doors<br>    &#125;<br>    <span class="hljs-keyword">return</span> mineObject;<br>&#125;<br><span class="hljs-comment">//ES6新增语法</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">demo</span>(<span class="hljs-params">color, doors</span>)&#123;<br>    <span class="hljs-keyword">var</span> mineObject&#123;<br>        color, <br>        doors<br>    &#125;<br>    <span class="hljs-keyword">return</span> mineObject;<br>&#125;<br></code></pre></td></tr></table></figure><p>当对象字面量里只有属性名称时，JS引擎会在可访问作用域中<strong>查找与其同名的变量</strong>，若能找到，则将其值赋予其同名属性</p></li><li><p>对象方法简写语法</p><p>可省略冒号和function关键字（类似于C++对象内部定义函数）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//一般方法</span><br><span class="hljs-keyword">let</span> demo=&#123;<br>    name : <span class="hljs-string">&quot;pika&quot;</span>,<br>    pikachu : <span class="hljs-title function_">fuction</span>(<span class="hljs-params"></span>)&#123;<br>    ...<br>    &#125;<br>&#125;<br><span class="hljs-comment">//ES6新增语法</span><br><span class="hljs-keyword">let</span> demo=&#123;<br>    name : <span class="hljs-string">&quot;pika&quot;</span>,<br>    <span class="hljs-title function_">pikachu</span>(<span class="hljs-params"></span>)&#123;<br>        ...<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></li></ol><p>​使用简写语法创建的方法含有一个name属性，其值为函数名</p><p>​<code>console.log(demo.pikachu.name);// 输出为 pikachu</code></p><p>​</p><ol start="3"><li><p>定义对象时属性名可为表达式</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> attribute=<span class="hljs-string">&quot;name&quot;</span><br><span class="hljs-keyword">let</span> demo=&#123;<br>    [<span class="hljs-string">&quot;first&quot;</span> + attribute]:<span class="hljs-string">&quot;Pikachu&quot;</span>,<span class="hljs-comment">//firstname:&quot;Pikachu&quot;,</span><br>    [<span class="hljs-string">&quot;last&quot;</span> + attribute]:<span class="hljs-string">&quot;Pika&quot;</span>     <span class="hljs-comment">//lastname:&quot;Pika&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>不局限于字符串拼接，任何表达式都可以，但都需要使用 []引用</p></li></ol><h4 id="解构赋值"><a href="#解构赋值" class="headerlink" title="解构赋值"></a>解构赋值</h4><p>在JS中，我们经常从某个对象或者数组中提取特定值付给变量，这种操作比较繁琐</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> book=&#123;<br>    <span class="hljs-attr">title</span>:<span class="hljs-string">&quot;高等数学&quot;</span>,<br>    <span class="hljs-attr">price</span>:<span class="hljs-number">99</span>,<br>    <span class="hljs-attr">category</span>:&#123;<br>    <span class="hljs-attr">id</span>: <span class="hljs-number">1</span>;<br>        <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;高等教育&quot;</span><br>&#125;<br>&#125;;<br><span class="hljs-comment">//提取对象中的值</span><br><span class="hljs-keyword">let</span> title = book.<span class="hljs-property">title</span>;<br><span class="hljs-keyword">let</span> price = book.<span class="hljs-property">title</span>;<br><span class="hljs-keyword">let</span> category = book.<span class="hljs-property">category</span>.<span class="hljs-property">name</span>;<br></code></pre></td></tr></table></figure><h5 id="对象解构"><a href="#对象解构" class="headerlink" title="对象解构"></a>对象解构</h5><p>对象解构的语法形式是在一个赋值操作符的左侧放置一个对象字面量，如上例中</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> book=&#123;<br>    <span class="hljs-attr">title</span>:<span class="hljs-string">&quot;高等数学&quot;</span>,<br>    <span class="hljs-attr">price</span>:<span class="hljs-number">99</span>,<br>    <span class="hljs-attr">isbn</span>:<span class="hljs-number">666</span><br>&#125;;<br><span class="hljs-comment">//提取对象中的值</span><br><span class="hljs-keyword">let</span> &#123;title, price, isbn&#125; = book;<br></code></pre></td></tr></table></figure><p>在这段代码中，book.title 的值被赋予给声明的变量 title，book.price 被赋给变量price，此处注意声明的<strong>变量名称和相应属性名相同</strong></p><p>若在提取值时已经声明了相应变量，则需要将语句使用小括号括起来：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> title;<br><span class="hljs-keyword">let</span> price;<br><br>&#123;title, price&#125; = book; <span class="hljs-comment">//报错！</span><br>(&#123;title,price&#125; = book);<span class="hljs-comment">//正确</span><br></code></pre></td></tr></table></figure><p>原因在于：<br>JS将开放的 {} 看作一个代码块，根据语法规则，代码块禁止放在赋值语句左侧。将其用（）括起来，将块语句转为一个表达式，得以正常进行解构</p><p>使用解构赋值表达式时，若在对象中不存在与指定的变量名同名的属性或对象中与其同名的属性值为<strong>undefined</strong>，则该局部变量值会被赋为<strong>undefined</strong>，在这种情况下，我们可以考虑为其指定一个默认参数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> &#123;title, price, game&#125; = book; <span class="hljs-comment">//在book对象中不存在game属性，因此此处局部变量game值被赋为undefined</span><br><span class="hljs-keyword">let</span> &#123;title, price, game = <span class="hljs-string">&#x27;it takes two&#x27;</span>&#125; = book;<span class="hljs-comment">//局部变量game值为&#x27;it takes two&#x27;</span><br></code></pre></td></tr></table></figure><p>若要将对象属性赋给<strong>不与其同名</strong>的变量，使用 “属性名 : 变量名”的语法形式：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> &#123;title : varFortitle, price : varForprice, isbn : varForisbn&#125; = book;<br></code></pre></td></tr></table></figure><p><strong>title : varFortitle</strong> 的含义是，从 book 的 title 属性中读取值并将其赋给变量 varFortitle，需要注意要赋予的变量名称在冒号右边，而要读取的属性名在冒号左边</p><p>关于嵌套对象的解构赋值语法，在此先不进行介绍</p><p>解构赋值语句的值是 &#x3D; 右边的对象，根据整个特点，常常在给函数传入对象作为参数时将对象属性的值赋给局部变量：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">demo</span>(<span class="hljs-params">book</span>)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(book.<span class="hljs-property">isbn</span>);<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(book.<span class="hljs-property">name</span>);<br>    ...<br>&#125;<br>    <br><span class="hljs-keyword">let</span> title;<br><span class="hljs-keyword">let</span> name;<br><span class="hljs-title function_">demo</span>(&#123;title, name&#125; = book);<span class="hljs-comment">//此时局部变量title的值为book.title的值，name同理，且将book对象传入了函数</span><br></code></pre></td></tr></table></figure><h5 id="数组解构"><a href="#数组解构" class="headerlink" title="数组解构"></a>数组解构</h5><p>数组解构采用 [] 而非 {}，由于数据结构的不同，数组并不需要考虑属性名的问题，因而语法相对简单一些</p><p>在数组解构语法中，变量值是根据数组中元素的顺序进行选取的，定义默认参数的方式也与对象类似</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br><span class="hljs-keyword">let</span> [a, b, c] = arr;       <span class="hljs-comment">//a = 1, b = 2, c = 3</span><br><span class="hljs-keyword">let</span> [ , , c] = arr;       <span class="hljs-comment">//c = 3</span><br><span class="hljs-keyword">let</span> [a, b, c, d] = arr     <span class="hljs-comment">//a = 1, b = 2, c = 3, d = undefine</span><br><span class="hljs-keyword">let</span> [a, b, c, d = <span class="hljs-number">4</span>] = arr <span class="hljs-comment">//a = 1, b = 2, c = 3, d = 4</span><br></code></pre></td></tr></table></figure><h4 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h4><p>ES6允许使用箭头”&#x3D;&gt;”定义函数，称为箭头函数。其语法多变，但都需要有函数参数，箭头，返回体组成</p><h5 id="箭头函数语法"><a href="#箭头函数语法" class="headerlink" title="箭头函数语法"></a>箭头函数语法</h5><p>单一参数、函数体只有返回语句：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> <span class="hljs-title function_">demo</span> = msg =&gt; msg;<br><span class="hljs-comment">//等价于</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">demo</span>(<span class="hljs-params">msg</span>)&#123;<br><span class="hljs-keyword">return</span> msg;<br>&#125;<br></code></pre></td></tr></table></figure><p>多参数则需要在参数的两侧添加圆括号：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> <span class="hljs-title function_">demo</span> = (<span class="hljs-params">user, msg</span>) =&gt; <span class="hljs-string">`<span class="hljs-subst">$&#123;user&#125;</span>, <span class="hljs-subst">$&#123;msg&#125;</span>`</span>;<span class="hljs-comment">//不记得的话复习一下一开始介绍的模板子向量</span><br><span class="hljs-comment">//等价于</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">demo</span>(<span class="hljs-params">user, msg</span>)&#123;<br><span class="hljs-keyword">return</span> user + <span class="hljs-string">&quot;, &quot;</span> + msg;<br>&#125;<br></code></pre></td></tr></table></figure><p>若函数无参&#x2F;函数体为空：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> <span class="hljs-title function_">demo</span> = (<span class="hljs-params"></span>) =&gt; <span class="hljs-string">&quot;pika!&quot;</span>;<br><span class="hljs-comment">//等价于</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">demo</span>(<span class="hljs-params"></span>)&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;pika!&quot;</span>;<br>&#125;<br><br><span class="hljs-comment">//若要创建空函数，则用空花括号引起函数体</span><br><span class="hljs-keyword">let</span> <span class="hljs-title function_">demo</span> = (<span class="hljs-params"></span>)=&gt; &#123;&#125;;<br><span class="hljs-comment">//相当于</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">demo</span>(<span class="hljs-params"></span>)&#123;&#125;;<br></code></pre></td></tr></table></figure><p>若函数体有多条语句,需用花括号把函数体引起</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> <span class="hljs-title function_">demo</span>(a,b) = &#123;<br>    a -= b;<br>    <span class="hljs-keyword">return</span> a;<br>&#125;<br><span class="hljs-comment">//等价于</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">demo</span>(<span class="hljs-params">a, b</span>)&#123;<br>a-=b;<br>    <span class="hljs-keyword">return</span> a;<br>&#125;<br></code></pre></td></tr></table></figure><p>若函数返回一个对象字面量，则需将其用圆括号引起，这是为了将其与函数体区分开</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> <span class="hljs-title function_">demo</span> = (<span class="hljs-params">color, doors</span>) =&gt; ( &#123;<span class="hljs-attr">color</span>:color,<span class="hljs-attr">doors</span>:doors&#125; );<br></code></pre></td></tr></table></figure><p>箭头函数也可以和对象解构一起使用</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> <span class="hljs-title function_">demo</span> = (<span class="hljs-params"> &#123;name, isbn&#125; </span>) =&gt; <span class="hljs-string">`The isbn of &#123;$name&#125; is &#123;$isbn&#125;.`</span>;<br><span class="hljs-comment">//等价于</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">demo</span>(<span class="hljs-params">name, isbn</span>)&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;The isbn of &quot;</span> name <span class="hljs-string">&quot; is &quot;</span> isbn <span class="hljs-string">&quot;.&quot;</span>; <br>&#125;<br><span class="hljs-comment">//调用时</span><br><span class="hljs-keyword">let</span> book = &#123;<br>    name : <span class="hljs-string">&quot;高等数学&quot;</span>,<br>    isbn : <span class="hljs-string">&quot;6666666&quot;</span><br>&#125;;<br><br><span class="hljs-keyword">let</span> output = <span class="hljs-title function_">demo</span>(book);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(output);    <span class="hljs-comment">//输出 The isbn of 高等数学 is 6666666.</span><br><br></code></pre></td></tr></table></figure><h5 id="箭头函数与this"><a href="#箭头函数与this" class="headerlink" title="箭头函数与this"></a>箭头函数与this</h5><p>在介绍箭头函数中的this值之前，我们有必要回顾一下 JS 中 this 关键字的相关知识</p><h6 id="this关键字"><a href="#this关键字" class="headerlink" title="this关键字"></a>this关键字</h6><p>JS中的 this 关键字与某些高级语言的 this 指针\引用有所不同，JS中的this值并不一定指向对象本身，其指向会根据当前执行上下文的变化而变化，我们来看一个例子</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> singerName = <span class="hljs-string">&quot;Troye&quot;</span>;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">singer</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">singerName</span>);<br>&#125;<br><br><span class="hljs-keyword">var</span> demo = &#123;<br>singerName : <span class="hljs-string">&quot;Chainsmoker&quot;</span>;<br>    <span class="hljs-attr">singer</span>: singer;<span class="hljs-comment">//函数是一等公民！</span><br>&#125;;<br><br><span class="hljs-title function_">singer</span>();     <span class="hljs-comment">// Troye</span><br>demo.<span class="hljs-title function_">singer</span>();<span class="hljs-comment">// Chainsmoker</span><br><span class="hljs-keyword">var</span> hey = demo.<span class="hljs-property">singer</span>;<br><span class="hljs-title function_">hey</span>();        <span class="hljs-comment">// Troye</span><br></code></pre></td></tr></table></figure><p>我们来分析上述代码</p><ul><li><p>执行 singer() 时，相当于执行windows.singer()，this指向的是window对象，而代码首行用<strong>var</strong>定义的  singerName 已自动成为了window对象的属性，因此this.singerName指向的是代码首行定义的全局变量，输出”Troye”</p><p>值得注意的是，若首行中的singerName用<strong>let</strong>定义，则会输出<strong>undefined</strong>，这也与我们一开始所讲到的<strong>let</strong>的性质相吻合</p></li><li><p>执行 demo.singer()时，this指针指向的是demo这个对象，于是其去demo属性中寻找singerName属性，输出为”Chainsmoker”</p></li><li><p>执行 hey()时，虽然其是通过demo.singer直接赋值的，但在执行hey()时，当前的执行上下文对象为window，因此也输出了”Troye“</p></li></ul><p>我们来看下一个例子</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> demo = &#123;<br>    singerName : <span class="hljs-string">&quot;Taylor&quot;</span>,<br>    <span class="hljs-title function_">singer</span>(<span class="hljs-params"></span>)&#123;<br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( <span class="hljs-variable language_">this</span>.<span class="hljs-property">singerName</span> );<br>        &#125;,<span class="hljs-number">5000</span>);<br>    &#125;<br>&#125;;<br><br>demo.<span class="hljs-title function_">singer</span>();<span class="hljs-comment">//输出为undefined</span><br></code></pre></td></tr></table></figure><p>之所以会输出undefined，是因为在调用demo.singer()时，我们执行了setTimeout函数。而在五秒以后才开始执行我们在setTimeout中定义的匿名函数，此时执行上下文对象为window，而window对象并没有singerName这个属性，因此输出为undefined</p><p>为了解决this指向的问题，我们可以调用函数对象的bind ()方法，将this明确的绑定到一个对象上，例如在上述例子中：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> singerName = <span class="hljs-string">&quot;Troye&quot;</span>;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">singer</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">singerName</span>);<br>&#125;<br><br><span class="hljs-keyword">var</span> demo = &#123;<br>singerName : <span class="hljs-string">&quot;Chainsmoker&quot;</span>;<br>    <span class="hljs-attr">singer</span>: singer;<span class="hljs-comment">//函数是一等公民！</span><br>&#125;;<br><br><span class="hljs-keyword">var</span> hey = demo.<span class="hljs-property">singer</span>.<span class="hljs-title function_">bind</span>(singer);<span class="hljs-comment">//将指针this与singer对象绑定</span><br><span class="hljs-title function_">hey</span>(); <span class="hljs-comment">//输出为Chainsmoker </span><br><br><br><span class="hljs-keyword">var</span> demo_2 = &#123;<br>    singerName : <span class="hljs-string">&quot;Taylor&quot;</span>,<br>    <span class="hljs-title function_">singer</span>(<span class="hljs-params"></span>)&#123;<br><span class="hljs-built_in">setTimeout</span>((<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( <span class="hljs-variable language_">this</span>.<span class="hljs-property">singerName</span> );<br>        &#125;).<span class="hljs-title function_">bind</span>(<span class="hljs-variable language_">this</span>),<span class="hljs-number">5000</span>);<span class="hljs-comment">//传入bind()的this目前指向的是demo_2这个对象，相当于.bind(demo_2)</span><br>    &#125;<br>&#125;;<br>demo_2.<span class="hljs-title function_">singer</span>();<span class="hljs-comment">//输出为 Taylor</span><br></code></pre></td></tr></table></figure><p>使用bind()方法实际上是创建了一个绑定函数，该函数的this被绑定到了传入的对象</p><p>我们可以使用箭头函数来避免创造绑定函数</p><h6 id="箭头函数的this"><a href="#箭头函数的this" class="headerlink" title="箭头函数的this"></a>箭头函数的this</h6><p>箭头函数中没有 this 绑定，需要通过查找作用域确定this的值。若箭头函数被非箭头函数包含，其this值与<strong>最近的包含它的非箭头函数</strong>的this值相同；若箭头函数为全局函数，则其this的值会指向全局对象（在JS中通常为window）</p><p>适时使用箭头函数会使代码变得简洁。如在之前的setTimeout的例子中，匿名函数用箭头函数形式：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> demo = &#123;<br>    singerName : <span class="hljs-string">&quot;Taylor&quot;</span>,<br>    <span class="hljs-title function_">singer</span>(<span class="hljs-params"></span>)&#123;<br><span class="hljs-comment">/*setTimeout(function()&#123;</span><br><span class="hljs-comment">            console.log( this.singerName );</span><br><span class="hljs-comment">        &#125;,5000);*/</span><br>        <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span>&#123;                      <span class="hljs-comment">//如果这里有疑问，就需要去复习匿名函数了</span><br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( <span class="hljs-variable language_">this</span>.<span class="hljs-property">singerName</span> ); <br>        &#125;,<span class="hljs-number">5000</span>);<br>    &#125;<br>&#125;;<br><br>demo.<span class="hljs-title function_">singer</span>();<span class="hljs-comment">//输出为Taylor</span><br></code></pre></td></tr></table></figure><p>总的来说，<strong>箭头函数中的this取决于其外部非箭头函数的this的值</strong></p><h5 id="使用箭头函数注意点"><a href="#使用箭头函数注意点" class="headerlink" title="使用箭头函数注意点"></a>使用箭头函数注意点</h5><ol><li><p>箭头函数无 this, super, arguments 和 new.target绑定。其 this, super, arguments 和 new.target值取决于其外部最近一层非箭头函数决定</p></li><li><p>箭头函数不能被用作构造函数，即无法通过new来调用</p></li><li><p>没有原型。由于箭头函数无法通过new调用，因此也没有为其构建相应原型的需求，即其无prototype属性</p></li><li><p>在函数生命周期内，this的值不可改变</p></li><li><p>不支持arguments对象，但仍然可以通过已命名的形参以及rest参数来访问函数的参数</p></li></ol><h4 id="Symbol"><a href="#Symbol" class="headerlink" title="Symbol"></a>Symbol</h4><p>ES6引进了一种新的数据类型——“Symbol”，表示独一无二的值</p><h5 id="Symbol值的创建"><a href="#Symbol值的创建" class="headerlink" title="Symbol值的创建"></a>Symbol值的创建</h5><p>一个具有Symbol类型的值被称为“符号类型值”，在JS中通过调用Symbol()函数动态生成一个匿名的、唯一的值，它没有字面量的写法</p><p>具体如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> a=<span class="hljs-title class_">Symbol</span>();<br><span class="hljs-keyword">let</span> b=<span class="hljs-title class_">Symbol</span>();<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a==b); <span class="hljs-comment">//false</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a);    <span class="hljs-comment">//Symbol()</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(b);   <span class="hljs-comment">//Symbol()</span><br></code></pre></td></tr></table></figure><p>由于Symbol函数会动态生成唯一值，因此a与b的值并不相等。Symbol是原始值，不能使用new Symbol() 创建Symbol值，且每一个Symbol实例是<strong>唯一的且不可改变的</strong></p><p>我们发现a与b在输出时均为Symbol()，即使两者值并不相同。因此我们可以通过在Symbal函数中添加字符串参数来对其实例增加描述，这个描述不可用于进行属性访问，且并<strong>不会对实例本身有任何影响</strong>，仅仅是为了方便调试：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> a = <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">&quot;pika&quot;</span>);<br><span class="hljs-keyword">let</span> b = <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">&quot;pika pi!&quot;</span>);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(b);<br><br><span class="hljs-keyword">let</span> d = a;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a == d); <span class="hljs-comment">//将a值赋给了d</span><br><br><span class="hljs-keyword">let</span> c = <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">&quot;pika&quot;</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a == c); <span class="hljs-comment">//a与c的Symbal描述一致  </span><br><br><span class="hljs-comment">//输出为：</span><br><span class="hljs-title class_">Symbol</span>(pika)<br><span class="hljs-title class_">Symbol</span>(pika pi!)<br><span class="hljs-literal">true</span><br><span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><p>由上可验证，不同的Symbol，即使有着相同描述，实例值本身并不相同；直接将Symbol值赋给另一个变量，两者值是相同的</p><h5 id="关于类型转换"><a href="#关于类型转换" class="headerlink" title="关于类型转换"></a>关于类型转换</h5><p>Symbol值比较特殊，没有与其逻辑等价的值，JS无法将其自动进行类型转换。我们只能通过调用其toString方法将其转换为字符串，即将Symbol()转换为”Symbol()”。除此以外，在尝试与其他类型值拼接&#x2F;运算时，则会报错</p><p>有一个例外是，Symbol值可以参与逻辑运算。因为JS将非空值都看为true，因此Symbol值在布尔运算中永远为true</p><h5 id="作为属性名"><a href="#作为属性名" class="headerlink" title="作为属性名"></a>作为属性名</h5><p>Symbol类型唯一比较合理的用法是用变量存储Symbol值，再用这个变量存储的值作为属性名来创建对象的属性，由于每一个Symbol值都不相等，因此对象的属性名永远不用担心重复的问题，这也是引入Symbol的初衷之一</p><p>考虑这样一种情况：两个不同的库想要向一个对象添加基本数据，可能它们都想在对象上设置某种标识符，假设要设置各自的ID。如果简单地使用诸如ID作为键，这样存在一个巨大的风险，就是多个库可能使用相同的键</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">lib1tag</span>(<span class="hljs-params">obj</span>) &#123;<br>    obj.<span class="hljs-property">id</span> = <span class="hljs-number">42</span>;<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">lib2tag</span>(<span class="hljs-params">obj</span>) &#123;<br>    obj.<span class="hljs-property">id</span> = <span class="hljs-number">369</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>通过使用 Symbol，每个库可以在实例化时生成所需的 Symbol。然后用生成 Symbol 的值做为对象的属性：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> library1property = <span class="hljs-title function_">uuid</span>(); <span class="hljs-comment">// random approach</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">lib1tag</span>(<span class="hljs-params">obj</span>) &#123;<br>    obj[library1property] = <span class="hljs-number">42</span>;<br>&#125;<br><span class="hljs-keyword">const</span> library2property = <span class="hljs-string">&quot;LIB2-NAMESPACE-id&quot;</span>; <span class="hljs-comment">// namespaced approach</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">lib2tag</span>(<span class="hljs-params">obj</span>) &#123;<br>    obj[library2property] = <span class="hljs-number">369</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>需要注意的是，Symbol作为对象属性名，相应值是不能使用点运算符获取的，只能使用中括号来获取，且该属性是公有的而非私有</p><p>要读取一个对象的Symbol属性，可以通过Object.getOwnPropertySymbols()和Reflect.ownKeys()方法得到</p><h5 id="共享的Symbol"><a href="#共享的Symbol" class="headerlink" title="共享的Symbol"></a>共享的Symbol</h5><p>如果想在不同的代码片段使用同一个Symbol值，可以通过使用 Symbol.for() 方法来实现，但与Symbol()不同的是，它要求必须给定一个字符串参数作为标识符以及描述，以此来辨别Symbol值</p><p>ES6提供了一个可以随时访问的全局Symbol注册表，当调用Symbol.for(‘demo’)时，JS会先去全局注册表中寻找标识符为 ‘demo’ 的值，如果找到了则返回这个值，如果没找到则创建一个以‘demo’为标识符的Symbol值，并将其注册到Symbol注册表中</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> a = <span class="hljs-title class_">Symbol</span>.<span class="hljs-title function_">for</span>(<span class="hljs-string">&quot;pika&quot;</span>);<br><span class="hljs-keyword">let</span> b = <span class="hljs-title class_">Symbol</span>.<span class="hljs-title function_">for</span>(<span class="hljs-string">&#x27;pika&#x27;</span>);<br><br><span class="hljs-keyword">let</span> c = <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">&#x27;pika&#x27;</span>);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a == b); <span class="hljs-comment">//true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a == c); <span class="hljs-comment">//false</span><br></code></pre></td></tr></table></figure><p>由此可见，Symbol.for()与Symbol()的区别在于：前者会将创建的Symbol注册到全局Symbol注册表中，当再次使用相同的key调用Symbol .for()时，会返回同一个Symbol值；而后者无论key值相同与否，都会创建一个新的、与已有的Symbol都不同的值</p><h4 id="类"><a href="#类" class="headerlink" title="类"></a>类</h4><p>绝大多数面向对象的编程语言支持类和类继承的特性，而 JS 却不支持这些特性，在 ES6 之前，我们需要混合使用构造函数和原型prototype来模拟定义一个对象并实现类的继承，这相当繁琐。在ES6中，引入了class关键字，使类的定义更接近C++、Java的语法</p><h5 id="类的定义"><a href="#类的定义" class="headerlink" title="类的定义"></a>类的定义</h5><p>如要定义一个Car类：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">car</span>&#123;<br>    <span class="hljs-comment">//构造函数</span><br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">sColor,iDoors</span>)&#123;<br><span class="hljs-variable language_">this</span>.<span class="hljs-property">color</span> = sColor;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">doors</span> = iDoors;<br>    &#125;,<br>    <span class="hljs-title function_">showColor</span>(<span class="hljs-params"></span>)&#123;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">color</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">let</span> mCar = <span class="hljs-keyword">new</span> <span class="hljs-title function_">car</span>(<span class="hljs-string">&#x27;red&#x27;</span>,<span class="hljs-number">4</span>);<br>mCar.<span class="hljs-title function_">showColor</span>();           <span class="hljs-comment">//red</span><br></code></pre></td></tr></table></figure><p>需要与C++对象区分的一点是，通过方法（可以理解为成员函数，如构造函数方法或者其他方法）创建的属性称为自由属性，自由属性只能为对象实例拥有，而不会出现在原型上。如上例中，color 和 doors 属性只会出现在mCar上，对象原型car本身并不含有这些属性。本例中写的方法 showColor 实际上是car.prototype的一个方法</p><p>类也可以用表达式创建，但本质上并没有任何区别，在此不多赘述</p><h5 id="访问器属性"><a href="#访问器属性" class="headerlink" title="访问器属性"></a>访问器属性</h5><p>访问器属性是通过关键字 get、set 跟一个空格后加一个标识符实现的，实际上是为了便于给某个自由属性定义取值和设值函数，在使用是直接以属性访问的方式使用。与自由属性不同的是，访问器属性需要在原型中直接创建</p><p>例如为上例中的car设置访问器属性</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">car</span>&#123;<br>    <span class="hljs-comment">//构造函数</span><br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">sColor,iDoors</span>)&#123;<br><span class="hljs-variable language_">this</span>.<span class="hljs-property">color</span> = sColor;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">doors</span> = iDoors;<br>    &#125;,<br>   <span class="hljs-comment">//只读</span><br>    <span class="hljs-keyword">get</span> <span class="hljs-title function_">desc</span>()&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;The color of the car is &#x27;</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">color</span>;<br>    &#125;<br>    <span class="hljs-keyword">get</span> <span class="hljs-title function_">color</span>()&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">color</span><br>    &#125;<br>    <span class="hljs-keyword">get</span> <span class="hljs-title function_">color</span>(<span class="hljs-params">value</span>)&#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">color</span> = value;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">let</span> iCar = ner <span class="hljs-title function_">car</span>(<span class="hljs-string">&#x27;red&#x27;</span>, <span class="hljs-number">4</span>);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-property">log</span> (iCar.<span class="hljs-property">color</span>);<span class="hljs-comment">//&#x27;red&#x27;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-property">log</span> (iCar.<span class="hljs-property">desc</span>); <span class="hljs-comment">//The color of the car is red</span><br>iCar.<span class="hljs-property">color</span> = <span class="hljs-string">&#x27;blue&#x27;</span>;     <span class="hljs-comment">//若未定义get访问器属性，则自由变量color无法通过此方法改变值</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-property">log</span> (iCar.<span class="hljs-property">color</span>);<span class="hljs-comment">//&#x27;blue&#x27;</span><br></code></pre></td></tr></table></figure><h5 id="静态方法关键字-static"><a href="#静态方法关键字-static" class="headerlink" title="静态方法关键字 static"></a>静态方法关键字 static</h5><p>ES6中引入的 static 关键字用于类方法定义时与C++中的 static 关键字较为类似，使用static关键字定义的静态方法只能通过对象原型（也就是类名）调用，无法通过对象实例调用</p><p>值得注意的是ES6中并未提供静态属性，因此无法在定义实例前加关键字static</p><h5 id="类的继承"><a href="#类的继承" class="headerlink" title="类的继承"></a>类的继承</h5><p>ES6提供了extends关键字用于更轻松的实现类的继承</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>&#123;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name</span>)&#123;<br><span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>    &#125;<br>    <br>    <span class="hljs-title function_">work</span>(<span class="hljs-params"></span>)&#123;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;working...&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> extend <span class="hljs-title class_">Person</span>&#123;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name, grade</span>)&#123;<br><span class="hljs-variable language_">super</span>(name);<span class="hljs-comment">//调用父类的构造函数</span><br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">grade</span> = grade;<br>    &#125;<br>    <span class="hljs-comment">//可重写继承于父类的方法,这会将其覆盖</span><br>    <span class="hljs-title function_">work</span>(<span class="hljs-params"></span>)&#123;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;studying...&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>若派生类显式定义了构造函数，则必须通过调用 super 来调用父类的构造函数，而且必须在访问this之前调用。若派生类未显式定义构造函数，则会默认自动调用父类的构造函数并向其传参</p><p>派生类可以重写继承于父类的方法，倘若要在重写的方法中调用父类的此方法，可以通过调用super来实现，如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//在子类work方法中调用父类work方法</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> extend <span class="hljs-title class_">Person</span>&#123;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name, grade</span>)&#123;<br><span class="hljs-variable language_">super</span>(name);<span class="hljs-comment">//调用父类的构造函数</span><br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">grade</span> = grade;<br>    &#125;<br>    <span class="hljs-comment">//可重写继承于父类的方法</span><br>    <span class="hljs-title function_">work</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-variable language_">super</span>.<span class="hljs-title function_">work</span>();<span class="hljs-comment">//调用父类方法 work </span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;studying...&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">let</span> stu = <span class="hljs-title class_">Student</span>(<span class="hljs-string">&quot;JJy&quot;</span>,<span class="hljs-number">59</span>);<br>stu.<span class="hljs-title function_">work</span>();   <span class="hljs-comment">//working...studying...</span><br></code></pre></td></tr></table></figure><h4 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h4><p>在ES5及早期版本中，JS中并未有模块体系，导致无法将一个引用拆分成不同部分，再将各部分组合起来使用，为此，JS社区中制定了一些解决方案，如CommonJS、AMD等等。ES6 在语言标准的层面上实现了模块功能，而且实现的相当简单，完全可以取代目前主流的解决方案，并已成为浏览器和服务器通用的模块解决方案</p><p>一个模块通常是一个单独的JS文件，文件中的变量，函数除非被导出，否则无法被外部使用</p><h5 id="export关键字"><a href="#export关键字" class="headerlink" title="export关键字"></a>export关键字</h5><p>使用 export 关键字放置在需要导出给其他模块的变量、函数或类声明前，以将其导出：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//导出函数</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">Pika</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Pika pi!&quot;</span>;<br>&#125;<br><span class="hljs-comment">//导出变量、类、对象</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">var</span> a;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> b = <span class="hljs-number">100</span>;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">let</span> c;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">car</span>&#123;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name</span>)&#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">var</span> pet = &#123;<br>    petName :<span class="hljs-string">&#x27;pakachu&#x27;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>我们也可以在模块尾部使用 export{} 集中导出：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Pika</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Pika pi!&quot;</span>;<br>&#125;<br><br><span class="hljs-keyword">var</span> a;<br><span class="hljs-keyword">const</span> b = <span class="hljs-number">100</span>;<br><span class="hljs-keyword">let</span> c;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">car</span>&#123;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name</span>)&#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">var</span> pet = &#123;<br>    petName :<span class="hljs-string">&#x27;pakachu&#x27;</span><br>&#125;<br><br><span class="hljs-comment">//可以集中导出</span><br><span class="hljs-keyword">export</span>&#123;<span class="hljs-title class_">Pika</span>,a,b&#125;;<br><span class="hljs-comment">//也可以逐个导出</span><br><span class="hljs-keyword">export</span> &#123;c&#125;;<br><span class="hljs-comment">//可以用 as 定义导出后的名称</span><br><span class="hljs-keyword">export</span> &#123;car <span class="hljs-keyword">as</span> <span class="hljs-title class_">Senna</span>&#125;;<span class="hljs-comment">//car是模块内部名，Senna是模块外部名</span><br><span class="hljs-comment">//一个模块可且仅可导出一个值作为默认值，需使用关键字 default </span><br><span class="hljs-comment">//导出默认值无需花括号</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> pet;<br></code></pre></td></tr></table></figure><ul><li>在需要导出的部分较多时，使用第二种方法更加清晰</li><li>导出时可以集中导出也可以逐步导出，集中导出需要使用逗号分隔</li><li>导出时可指定导出后的名称，用 as 关键字来指定</li><li>一个模块可且仅可导出一个值作为默认值，需使用关键字 default ，导出默认值时无需花括号</li></ul><h5 id="import关键字"><a href="#import关键字" class="headerlink" title="import关键字"></a>import关键字</h5><p>使用 import 关键字来导入外部模块导出的功能，import 语句包含两部分：要导入部分的标识符以及来源：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//假设要导入上例中模块</span><br><span class="hljs-keyword">import</span> &#123; a, b, c &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./module&quot;</span>;       <span class="hljs-comment">//可同时导入多个值</span><br><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">Senna</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./module&quot;</span>;         <span class="hljs-comment">//导入的名称是 Senna 而不是 car</span><br><span class="hljs-keyword">import</span> pet <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./module&quot;</span>;               <span class="hljs-comment">//默认值的导入同样不需要花括号</span><br><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">Pika</span> <span class="hljs-keyword">as</span> <span class="hljs-title class_">Pikachu</span>&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./module&quot;</span>;<span class="hljs-comment">//同样使用 as 来定义导入后使用名称Pikachu</span><br><br><span class="hljs-title class_">Pikachu</span>();                                <span class="hljs-comment">//使用Pikachu而不是Pika</span><br></code></pre></td></tr></table></figure><p>需要注意的是，导入和导出一般在模块顶部进行</p><h4 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h4><p>JS 引擎是基于单线程事件循环的概念构建的，它采用任务队列的方式进行，JS 执行异步调用的传统方式是时间和回调函数，随着应用的复杂化，时间和回调函数要满足一个开发者的需求，往往会变得比较复杂，为此，ES6 给出了 Promise 这一更加简单的异步编程解决方案</p><h5 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h5><p>一个Promise对象可以通过 Promise 构造函数进行创建，这个构造函数只接受一个参数：包含用来初始化 Promise 代码的执行函数，在执行函数中包含需要异步执行的代码，其只接受两个参数 ：<strong>resolve()</strong> 和 <strong>reject()</strong> 函数，这两个函数由JS引擎提供，我们不需要去编写。当异步代码执行成功时，调用 <strong>resolve()</strong> 函数；失败时，则调用 **reject()**函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> demo = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">resolve, reject</span>) &#123;<br>    <span class="hljs-comment">//开启异步操作</span><br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">var</span> c = <span class="hljs-number">3</span> / <span class="hljs-number">1</span>;<br>            <span class="hljs-title function_">resolve</span>(c);<br>        &#125;<span class="hljs-keyword">catch</span>(exp)&#123;<br>            <span class="hljs-title function_">reject</span>(exp);<br>        &#125;<br>    &#125; ,<span class="hljs-number">3000</span>);<br>&#125;);<br></code></pre></td></tr></table></figure><p>在执行器函数中模拟了一个异步调用，在3秒后执行除法操作，如果未抛出异常则调用 resolved 函数，反之则调用 reject 函数</p><p>每一个Promise都会经历一个短暂的声明周期：先是处于运行中（pending）的状态，此时代表着执行函数内的操作尚未完成，因此它也叫做未处理（unsettled）状态。一旦异步操作执行结束，便变为已处理（settled）状态，此时根据执行结果进入以下两个状态之一：</p><ol><li>fufilled : Promise异步操作成功完成</li><li>rejected : 由于程序错误或者其他原因， 异步操作未能完成</li></ol><p>一旦Promise状态改变，就不会再变，任何时候都能得到这个结果</p><p>在Promise状态改变后，我们通过调用 Promise 对象的<strong>then</strong>方法对不同的状态作相应的处理</p><p><strong>then</strong>方法接受两个函数作为参数，第一个是 Promise 变为 fufilled 状态时调用的函数，<strong>所有传入resolve中的形参都会被自动传递给这个函数</strong>，第二个是 Promise 变为 rejected 状态时调用的函数，<strong>所有传入reject中的形参都会被自动传递给这个函数</strong>。我们接着上面的例子，完善相应的代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> demo = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">resolve, reject</span>) &#123;<br>    <span class="hljs-comment">//开启异步操作</span><br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">var</span> c = <span class="hljs-number">3</span> / <span class="hljs-number">0</span>;<br>            <span class="hljs-comment">//throw new Error(&quot;error!&quot;)</span><br>            <span class="hljs-title function_">resolve</span>(c);<br>        &#125;<span class="hljs-keyword">catch</span>(exp)&#123;<br>            <span class="hljs-title function_">reject</span>(exp);<br>        &#125;<br>    &#125; ,<span class="hljs-number">3000</span>);<br>&#125;);<br><span class="hljs-comment">//调用then方法</span><br>demo.<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">value</span>)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;The value is &#x27;</span>+ value);<span class="hljs-comment">//这里的value值是传入resolve中的c的值，也就是3</span><br>&#125;,<span class="hljs-keyword">function</span>(<span class="hljs-params">errhhh</span>)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(errhhh.<span class="hljs-property">message</span>);<span class="hljs-comment">//如果执行函数中并未注释掉throw语句，则此处errhhh为catch到的异常</span><br>&#125;);<br><br></code></pre></td></tr></table></figure><p><strong>then</strong> 的两个参数都是可选的，如果只在失败后进行相应处理，可以给 <strong>then</strong> 方法的第一个参数传入null</p><p>Promise 对象还有一个 <strong>catch</strong>方法，这个方法只用于在异步执行失败后进行处理，等价于上文中 <strong>then</strong> 方法第一个函数传入null，在实际应用中，更多将 <strong>then</strong> 和 <strong>catch</strong> 方法结合起来使用，并通过箭头函数使代码更加简洁易读。如上例可改写为：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs Javascript"><span class="hljs-keyword">var</span> demo = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">resolve, reject</span>) &#123;<br>    <span class="hljs-comment">//开启异步操作</span><br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">var</span> c = <span class="hljs-number">3</span> / <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;error!&quot;</span>)<br>            <span class="hljs-title function_">resolve</span>(c);<br>        &#125; <span class="hljs-keyword">catch</span> (exp) &#123;<br>            <span class="hljs-title function_">reject</span>(exp);<br>        &#125;<br>    &#125;, <span class="hljs-number">3000</span>);<br>&#125;);<br><br>demo.<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">value</span>) =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;The value is &#x27;</span> + value))<br>    .<span class="hljs-title function_">catch</span>(<span class="hljs-function">(<span class="hljs-params">errhhh</span>) =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(errhhh.<span class="hljs-property">message</span>)); <span class="hljs-comment">//这里可以采用方法链调用，</span><br> <span class="hljs-comment">//说明then返回值是一个Promise对象（实际上catch也是）</span><br><span class="hljs-comment">//输出：error！</span><br></code></pre></td></tr></table></figure><h5 id="Promise的方法链调用"><a href="#Promise的方法链调用" class="headerlink" title="Promise的方法链调用"></a>Promise的方法链调用</h5><p>Promise和其他对象一样，也支持方法链调用，如上述代码所示。每次调用 <strong>then、catch</strong> 方法时，实际上是创建并返回了一个Promise，因此可以将Promise串联匿名使用。在串联调用是，只有当前一个Promise对象完成或者被拒绝时，后一个Promise对象才会被调用</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> demo = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">resolve, reject</span>) &#123;<br>    <span class="hljs-comment">//调用setTimeout模拟异步操作</span><br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-keyword">let</span> intArr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(<span class="hljs-number">20</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">20</span>; ++i) &#123;<br>            intArr[i] = <span class="hljs-built_in">parseInt</span>(<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>() * <span class="hljs-number">20</span>, <span class="hljs-number">10</span>);<br>        &#125;<br>        <span class="hljs-comment">//生成随机数组后调用resolve</span><br>        <span class="hljs-title function_">resolve</span>(intArr);<br>    &#125;, <span class="hljs-number">3000</span>);<br><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;输出有序数组&quot;</span>);<br>&#125;);<br><br>demo.<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">randomArr</span>) =&gt;</span> &#123;<br>    randomArr.<span class="hljs-title function_">sort</span>(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> a - b);<span class="hljs-comment">//递增排序</span><br>    <span class="hljs-keyword">return</span> randomArr;               <span class="hljs-comment">//通过return将值传给后续即将被调用的Promise</span><br>&#125;).<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">orderedArr</span>) =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(orderedArr));<br></code></pre></td></tr></table></figure><p>上述代码的输出结果如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript">输出有序数组<br>[<br>   <span class="hljs-number">0</span>,  <span class="hljs-number">0</span>,  <span class="hljs-number">0</span>,  <span class="hljs-number">1</span>,  <span class="hljs-number">1</span>,  <span class="hljs-number">3</span>,  <span class="hljs-number">3</span>,  <span class="hljs-number">7</span>,  <span class="hljs-number">8</span>,  <span class="hljs-number">8</span>,  <span class="hljs-number">9</span>,  <span class="hljs-number">9</span>,  <span class="hljs-number">10</span>,  <span class="hljs-number">12</span>,  <span class="hljs-number">13</span>,  <span class="hljs-number">13</span>,  <span class="hljs-number">14</span>,  <span class="hljs-number">16</span>,  <span class="hljs-number">16</span>,  <span class="hljs-number">17</span><br>]<br></code></pre></td></tr></table></figure><p>说明：</p><ol><li><p>在执行函数中的20个随机数生成完毕后，调用 <strong>resolve</strong> 函数并将数组传入。随后 <strong>then</strong>  方法的完成处理函数被调用，对数组进行排序，完成处理函数将排好序的数组通过关键字 <strong>return</strong> 传入下一个Promise，而第一个<strong>then</strong> 方法结束后返回了一个Promise对象。紧接着该对象的 <strong>then</strong> 方法被调用，其完成处理函数接收由上一个 <strong>then</strong> 方法排好序的数组，并将其输出</p></li><li><p>Promise链式调用时，有一个重要特性是可以通过在完成处理函数中指定一个返回值（如上例中的 <strong>return randomArr</strong>），从而沿着Promise链传递数据</p></li></ol><p>在完成处理函数或拒绝处理程序中也可能出现一个错误，通过链式调用可以很好的捕获这些错误代码，甚至为其提供错误处理程序。</p><p>假设上例中排序过程中可能出现错误：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> demo = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">resolve, reject</span>) &#123;<br>    <span class="hljs-comment">//调用setTimeout模拟异步操作</span><br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-keyword">let</span> intArr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(<span class="hljs-number">20</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">20</span>; ++i) &#123;<br>            intArr[i] = <span class="hljs-built_in">parseInt</span>(<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>() * <span class="hljs-number">20</span>, <span class="hljs-number">10</span>);<br>        &#125;<br>        <span class="hljs-comment">//生成随机数组后调用resolve</span><br>        <span class="hljs-title function_">resolve</span>(intArr);<br>    &#125;, <span class="hljs-number">3000</span>);<br><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;输出有序数组&quot;</span>);<br>&#125;);<br><br>demo.<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">randomArr</span>) =&gt;</span> &#123;<br>    randomArr.<span class="hljs-title function_">sort</span>(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> a - b);<br>    <span class="hljs-keyword">throw</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;Sorting Error!&quot;</span>);     <span class="hljs-comment">//手动抛出异常模拟完成处理函数运行过程中抛出异常</span><br>    <span class="hljs-keyword">return</span> randomArr;<br>&#125;).<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">orderedArr</span>) =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(orderedArr),<br>        <span class="hljs-function">(<span class="hljs-params">errmsg</span>) =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(errmsg.<span class="hljs-property">message</span>));<br></code></pre></td></tr></table></figure><p>输出为：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript">输出有序数组<br><span class="hljs-title class_">Sorting</span> <span class="hljs-title class_">Error</span>!<br></code></pre></td></tr></table></figure><p>需要注意的是，在Promise中如果没有使用 <strong>catch</strong> 函数指定错误处理函数，那么Promise对象抛出的错误将不会被传递到外层代码</p><p>总的来说，通过链式调用，<strong>前一个Promise在状态确定后执行的完成处理函数或错误处理函数相当于后一个Promise对象的执行函数</strong>！！</p><h5 id="创建已处理的Promise对象，"><a href="#创建已处理的Promise对象，" class="headerlink" title="创建已处理的Promise对象，"></a>创建已处理的Promise对象，</h5><p>有时候我们想将一个现有的对象转换为一个Promise对象，这时我们可以通过调用 <strong>Promise.resolve()</strong> 方法来实现，其参数分为下列三种情况：</p><ol><li><p>若参数本身就是一个Promise对象，则直接将其返回</p></li><li><p>若参数是一个具有 <strong>then</strong> 方法的对象（我们叫它 <strong>thenable</strong> 对象），则立即执行这个 <strong>thenable</strong> 对象的 <strong>then</strong> 方法，再根据其执行是否成功创建并返回 fulfilled 态或者 reject 态的Promise对象（类似于方法链调用的前后关系——前一个Promise在状态确定后执行的完成处理函数或错误处理函数相当于后一个Promise对象的执行函数）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> demo = &#123;<br>    <span class="hljs-title function_">then</span>(<span class="hljs-params">resolve, reject</span>) &#123;<br>        <span class="hljs-title function_">resolve</span>(<span class="hljs-string">&quot;pika!&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">var</span> a = <span class="hljs-number">10</span>; <span class="hljs-comment">//a不是Promise对象</span><br><br>a = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(demo);<br>a.<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">value</span>) =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(value)); <span class="hljs-comment">//a可以调用then方法的完成处理函数，其是一个fulfilled态的Promise对象</span><br><br><span class="hljs-comment">//输出为 pika!</span><br></code></pre></td></tr></table></figure></li><li><p>若参数为空或为基本数据类型，或是不具有 <strong>then</strong> 方法的对象，那么会返回一个 fulfilled 状态的Promise对象，并将参数传递给返回的Promise对象的 <strong>then</strong> 方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> a = <span class="hljs-number">10</span>; <span class="hljs-comment">//a不是Promise对象</span><br><br>a = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-string">&quot;hello!&quot;</span>);<br>a.<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">value</span>) =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(value)); <span class="hljs-comment">//a可以调用then方法的完成处理函数，其是一个fulfilled态的Promise对象</span><br><br><span class="hljs-comment">//输出为 hello! </span><br></code></pre></td></tr></table></figure></li></ol><p>通常来说，如果不知道一个值value是否为Promise对象，可以不管三七二十一，直接调用 <strong>Promise.resolve(value)</strong> ，这样子就能把value当作Promise对象使用了</p><p><strong>Promise.reject()</strong> 也会返回一个新的Promise对象，与<strong>Promise.resolve</strong> 十分类似，唯一不同的是若参数为第三种情况会默认返回状态为 rejected 的Promise对象，接收错误信息并传递给指定好的错误处理函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> a = <span class="hljs-number">10</span>; <span class="hljs-comment">//a不是Promise对象</span><br><br>a = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(<span class="hljs-string">&quot;hello!&quot;</span>);<br>a.<span class="hljs-title function_">catch</span>(<span class="hljs-function">(<span class="hljs-params">value</span>) =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(value)); <span class="hljs-comment">//a可以调用then方法的完成处理函数，其是一个fulfilled态的Promise对象</span><br><br><span class="hljs-comment">//输出为 hello!</span><br></code></pre></td></tr></table></figure><h5 id="响应多个Promise"><a href="#响应多个Promise" class="headerlink" title="响应多个Promise"></a>响应多个Promise</h5><p>如果需要等待多个Promise处理完成后再进行下一步操作，可以调用 <strong>Promise.all()</strong> 方法。该方法接受一个参数并返回一个新的Promise对象，参数是一个包含多个Promise的可迭代对象（例如数组）。返回的Promise对象只有当参数中的所有Promise对象全成功时才会触发成功态，一旦参数中有任何一个Promise对象失败，则返回的Promise对象触发失败。这个新的Promise对象会在触发成功时将参数中全部Promise对象返回值以数组的形式传给其完成处理函数，顺序与参数中可迭代对象中的Promise顺序保持一致；相应地，在触发失败时会将参数列表中第一个触发失败的Promise的错误信息返回给其失败处理函数。</p><p><strong>Promise.all()</strong> 方法适合处理Promise对象集合，如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> promise_1 = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-number">5</span>); <br><span class="hljs-keyword">let</span> promise_2 = <span class="hljs-number">10</span>;                 <span class="hljs-comment">//不是Promise对象</span><br><span class="hljs-keyword">let</span> promise_3 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=&gt;</span><span class="hljs-built_in">setTimeout</span>(resolve, <span class="hljs-number">500</span>, <span class="hljs-string">&quot;Hello!&quot;</span>));<span class="hljs-comment">//模拟异步，执行成功</span><br><span class="hljs-keyword">let</span> promise_4 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=&gt;</span><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span>&#123;                    <span class="hljs-comment">//模拟异步，执行失败</span><br>    <span class="hljs-keyword">try</span>&#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;Error!&quot;</span>);<br>    &#125;<span class="hljs-keyword">catch</span>(ex)&#123;<br>        <span class="hljs-title function_">reject</span>(ex);<br>    &#125;<br>&#125;,<span class="hljs-number">3000</span>));<br><br><span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">all</span>([promise_1,promise_2,promise_3]).<span class="hljs-title function_">then</span>(<br>    <span class="hljs-function"><span class="hljs-params">value</span>=&gt;</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(value));<br><br><span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">all</span>([promise_1,promise_3,promise_4]).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">value</span>=&gt;</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Hello!&quot;</span>))<br>                                            .<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">errmsg</span>=&gt;</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(errmsg.<span class="hljs-property">message</span>));<br>                                            <br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript">[ <span class="hljs-number">5</span>, <span class="hljs-number">10</span>, <span class="hljs-string">&#x27;Hello!&#x27;</span> ]<br><span class="hljs-title class_">Error</span>!<br></code></pre></td></tr></table></figure><p>由上可知，如果一个非Promise对象传入了 <strong>Promise.all()</strong> 中，其会忽略该值，也会将其放入返回的数组的相应位置（假设全部Promise对象都成功）</p><p>ES6还提供了<strong>Promise.race()</strong> 方法，与 <strong>Promise.all()</strong> 方法不同的是，<strong>Promise.race()</strong> 方法只要有一个Promise成功或者失败，则返回一个相应状态的Promise对象，并将对应的信息传入相应的处理函数，因此其返回对象的状态取决于参数列表最早处理完成的Promise对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> promise_3 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=&gt;</span><span class="hljs-built_in">setTimeout</span>(resolve, <span class="hljs-number">500</span>, <span class="hljs-string">&quot;Hello!&quot;</span>));<span class="hljs-comment">//延时500ms</span><br><span class="hljs-keyword">let</span> promise_4 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=&gt;</span><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span>&#123;                    <span class="hljs-comment">//延时3000ms</span><br>    <span class="hljs-keyword">try</span>&#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;Error!&quot;</span>);<br>    &#125;<span class="hljs-keyword">catch</span>(ex)&#123;<br>        <span class="hljs-title function_">reject</span>(ex);<br>    &#125;<br>&#125;,<span class="hljs-number">3000</span>));      <br><br><span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">race</span>([promise_3,promise_4]).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">value</span>=&gt;</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(value))<br>                                            .<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">errmsg</span>=&gt;</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(errmsg.<span class="hljs-property">message</span>));<br><span class="hljs-comment">//输出 Hello</span><br><span class="hljs-comment">//若将promise_4 中异步操作延迟调为&lt;500ms,则输出 Error</span><br></code></pre></td></tr></table></figure><h4 id="async函数"><a href="#async函数" class="headerlink" title="async函数"></a>async函数</h4><p>async函数是在ES8标准中引入的，async函数是使用 <strong>async</strong>关键字声明的函数，在其内部可以使用<strong>await</strong>关键字，表明紧跟在后面的表达式需要执行，其后的代码需要等待执行完毕后再继续执行</p><p>使用<strong>async</strong>函数和<strong>await</strong>关键字，可以更简洁的写出基于Promise的异步行为</p><h5 id="基本用法-1"><a href="#基本用法-1" class="headerlink" title="基本用法"></a>基本用法</h5><p>async函数会返回一个Promise对象，如果其显式返回值不是一个Promise对象，则会将其隐式包装在Promise中并返回</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">demo</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Hello&quot;</span>;<br>&#125;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(demo);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">demo</span>());<br><span class="hljs-title function_">demo</span>().<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">value</span>=&gt;</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(value));<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript">[<span class="hljs-title class_">AsyncFunction</span>: demo]<br><span class="hljs-title class_">Promise</span> &#123; <span class="hljs-string">&#x27;Hello&#x27;</span> &#125;<br><span class="hljs-title class_">Hello</span><br></code></pre></td></tr></table></figure><p>async函数内部return返回的值，会成为then()方法中回调函数的参数</p><p>async函数中可以有 <strong>await</strong> 表达式，当遇到它时，函数会先暂时停止执行，等待 <strong>await</strong> 后触发的异步操作完成后，再继续async函数的执行:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">demo</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span>=&gt;</span><br>        <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;延时任务&quot;</span>);<br>            <span class="hljs-title function_">resolve</span>();<br>    &#125;, <span class="hljs-number">1000</span>));<br>&#125;<br><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">asyDemo</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;即将开始&quot;</span>);<br>    <span class="hljs-keyword">await</span> <span class="hljs-title function_">demo</span>();<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;异步处理完成&quot;</span>);<br>&#125;<br><br><span class="hljs-title function_">asyDemo</span>();<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript">即将开始<br>延时任务<br>异步处理完成<br></code></pre></td></tr></table></figure><p>在 <strong>await</strong> 关键字后面，可以是Promise对象或者原始类型值，若为原始类型值，则会自动转为resolved状态的Promise对象</p><p>一个 <strong>async</strong> 函数的函数体可看作是由0或多个 <strong>await</strong> 表达式分成的代码块，每个代码块代表一个异步执行操作（<strong>await</strong>后跟着的）及同步执行代码（两个<strong>await</strong>之间的代码）</p><h5 id="await和并行任务执行"><a href="#await和并行任务执行" class="headerlink" title="await和并行任务执行"></a>await和并行任务执行</h5><p>在async函数中可以有多个<strong>await</strong>任务，如果这多个任务之间没有明确要求执行顺序，可以使用**Promise.all()**方法来并行执行多个任务</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">demo</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span>=&gt;</span><br>        <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;延时任务--1s&quot;</span>);<br>            <span class="hljs-title function_">resolve</span>(<span class="hljs-string">&quot;任务1执行完成&quot;</span>);<br>    &#125;, <span class="hljs-number">1000</span>));<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">demo_2</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span>=&gt;</span><br>        <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;延时任务--2s&quot;</span>);<br>            <span class="hljs-title function_">resolve</span>(<span class="hljs-string">&quot;任务2执行完成&quot;</span>);<br>    &#125;, <span class="hljs-number">2000</span>));<br>&#125;<br><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">asyDemo</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;即将开始&quot;</span>);<br>    <span class="hljs-keyword">await</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">all</span>([<span class="hljs-title function_">demo</span>(),<span class="hljs-title function_">demo_2</span>()])<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;异步处理完成&quot;</span>);<br>&#125;<br><br><span class="hljs-title function_">asyDemo</span>();<br></code></pre></td></tr></table></figure><p>输出为:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript">即将开始<br>延时任务--1s<br>延时任务--2s<br>异步处理完成<br></code></pre></td></tr></table></figure><p>我们来看一个<strong>await</strong>表达式的值是什么，将上例中的asyDemo函数改为：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">asyDemo</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;即将开始&quot;</span>);<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">await</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">all</span>([<span class="hljs-title function_">demo</span>(),<span class="hljs-title function_">demo_2</span>()]));<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;异步处理完成&quot;</span>);<br>&#125;<br><br></code></pre></td></tr></table></figure><p>输出为：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript">即将开始<br>延时任务--1s<br>延时任务--2s<br>[ <span class="hljs-string">&#x27;任务1执行完成&#x27;</span>, <span class="hljs-string">&quot;任务2执行完成&quot;</span> ]<br>异步处理完成<br></code></pre></td></tr></table></figure><p>此处表达式的值是**Promise.all()**返回的值，说明表达式的值为其后跟的Promise对象异步执行完毕后返回的信息</p><h5 id="使用async函数重写Promise链"><a href="#使用async函数重写Promise链" class="headerlink" title="使用async函数重写Promise链"></a>使用async函数重写Promise链</h5><p>Promise方法链实质上是多个Promise对象连续执行的一种简写形式，将其拆解为一个个独立的Promise对象，在<strong>async</strong>函数中对Promise对象单独或部分集中（使用<strong>Promise.all()或Promise.race()<strong>聚合）使用</strong>await</strong>表达式，即可将Promise链改写为<strong>async</strong>函数形式，在此不再赘述</p><h5 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h5><p>如果<strong>async</strong>函数内部抛出错误，其返回的Promise对象会被置为reject状态，而抛出的错误信息可以通过**catch()**方法的回调函数接收到，代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">asyDemo</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">await</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=&gt;</span>&#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;错误！&quot;</span>);<br>    &#125;)<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Hello&quot;</span>;<br>&#125;<br><br><span class="hljs-title function_">asyDemo</span>().<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">value</span>=&gt;</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(value))<br>         .<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">errmsg</span>=&gt;</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(errmsg.<span class="hljs-property">message</span>));<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">错误！<br></code></pre></td></tr></table></figure><p>在上述代码中，<strong>await</strong>后面的Promise对象抛出错误对象，<strong>async</strong> 函数返回reject状态的Promise对象，其catch()函数被调用，参数即为抛出的错误对象</p><p>若想要在内部的Promise出错时不返回错误对象，可将<strong>await</strong>写入<strong>try&#x2F;catch</strong>语句块中，在 <strong>async</strong> 内部进行相应错误处理，如</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">asyDemo</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">try</span>&#123;<br>    <span class="hljs-keyword">await</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=&gt;</span>&#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;错误！&quot;</span>);<br>    &#125;)<br>    &#125;<span class="hljs-keyword">catch</span>(ex)&#123;<br>        <span class="hljs-comment">//错误处理</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Hello!&quot;</span>;<br>&#125;<br><br><span class="hljs-title function_">asyDemo</span>().<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">value</span>=&gt;</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(value))<br>         .<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">errmsg</span>=&gt;</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(errmsg.<span class="hljs-property">message</span>));<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Hello</span>!<br></code></pre></td></tr></table></figure><p>如果有多个<strong>await</strong>，可以统一放入<strong>try&#x2F;catch</strong>语句块中</p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端</tag>
      
      <tag>ES6</tag>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
